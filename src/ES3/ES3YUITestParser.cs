//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 ES3YUITest.g 2013-02-17 16:06:41

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using Antlr3.ST;
using Antlr3.ST.Language;
/*
 * YUI Test Coverage
 * Author: Nicholas C. Zakas <nzakas@yahoo-inc.com>
 * Copyright (c) 2009, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 *     http://developer.yahoo.net/yui/license.txt
 *     
 * Ported to C# by Joe Doyle <joe@joedoyle.us>
 * Copyright (c) 2013, Joe Doyle.  All rights reserved.
 * This C# Port is also licensed under the BSD License.
 */
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ES3YUITestParser : Antlr.Runtime.Parser
{
    internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "ADD", "ADDASS", "AND", "ANDASS", "ARGS", "ARRAY", "ASSIGN", "BLOCK", "BOOLEAN", "BREAK", "BSLASH", "BYFIELD", "BYINDEX", "BYTE", "BackslashSequence", "CALL", "CASE", "CATCH", "CEXPR", "CHAR", "CLASS", "COLON", "COMMA", "CONST", "CONTINUE", "CR", "CharacterEscapeSequence", "DEBUGGER", "DEC", "DEFAULT", "DELETE", "DIV", "DIVASS", "DO", "DOT", "DOUBLE", "DQUOTE", "DecimalDigit", "DecimalIntegerLiteral", "DecimalLiteral", "ELSE", "ENUM", "EOL", "EQ", "EXPORT", "EXPR", "EXTENDS", "EscapeSequence", "ExponentPart", "FALSE", "FF", "FINAL", "FINALLY", "FLOAT", "FOR", "FORITER", "FORSTEP", "FUNCTION", "GOTO", "GT", "GTE", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "IF", "IMPLEMENTS", "IMPORT", "IN", "INC", "INSTANCEOF", "INT", "INTERFACE", "INV", "ITEM", "Identifier", "IdentifierNameASCIIStart", "IdentifierPart", "IdentifierStartASCII", "LABELLED", "LAND", "LBRACE", "LBRACK", "LF", "LONG", "LOR", "LPAREN", "LS", "LT", "LTE", "LineTerminator", "MOD", "MODASS", "MUL", "MULASS", "MultiLineComment", "NAMEDVALUE", "NATIVE", "NBSP", "NEG", "NEQ", "NEW", "NOT", "NSAME", "NULL", "OBJECT", "OR", "ORASS", "OctalDigit", "OctalEscapeSequence", "OctalIntegerLiteral", "PACKAGE", "PAREXPR", "PDEC", "PINC", "POS", "PRIVATE", "PROTECTED", "PS", "PUBLIC", "QUE", "RBRACE", "RBRACK", "RETURN", "RPAREN", "RegularExpressionChar", "RegularExpressionFirstChar", "RegularExpressionLiteral", "SAME", "SEMIC", "SHL", "SHLASS", "SHORT", "SHR", "SHRASS", "SHU", "SHUASS", "SP", "SQUOTE", "STATIC", "SUB", "SUBASS", "SUPER", "SWITCH", "SYNCHRONIZED", "SingleLineComment", "StringLiteral", "TAB", "THIS", "THROW", "THROWS", "TRANSIENT", "TRUE", "TRY", "TYPEOF", "USP", "UnicodeEscapeSequence", "VAR", "VOID", "VOLATILE", "VT", "WHILE", "WITH", "WhiteSpace", "XOR", "XORASS", "ZeroToThree"
	};
    public const int EOF = -1;
    public const int ABSTRACT = 4;
    public const int ADD = 5;
    public const int ADDASS = 6;
    public const int AND = 7;
    public const int ANDASS = 8;
    public const int ARGS = 9;
    public const int ARRAY = 10;
    public const int ASSIGN = 11;
    public const int BLOCK = 12;
    public const int BOOLEAN = 13;
    public const int BREAK = 14;
    public const int BSLASH = 15;
    public const int BYFIELD = 16;
    public const int BYINDEX = 17;
    public const int BYTE = 18;
    public const int BackslashSequence = 19;
    public const int CALL = 20;
    public const int CASE = 21;
    public const int CATCH = 22;
    public const int CEXPR = 23;
    public const int CHAR = 24;
    public const int CLASS = 25;
    public const int COLON = 26;
    public const int COMMA = 27;
    public const int CONST = 28;
    public const int CONTINUE = 29;
    public const int CR = 30;
    public const int CharacterEscapeSequence = 31;
    public const int DEBUGGER = 32;
    public const int DEC = 33;
    public const int DEFAULT = 34;
    public const int DELETE = 35;
    public const int DIV = 36;
    public const int DIVASS = 37;
    public const int DO = 38;
    public const int DOT = 39;
    public const int DOUBLE = 40;
    public const int DQUOTE = 41;
    public const int DecimalDigit = 42;
    public const int DecimalIntegerLiteral = 43;
    public const int DecimalLiteral = 44;
    public const int ELSE = 45;
    public const int ENUM = 46;
    public const int EOL = 47;
    public const int EQ = 48;
    public const int EXPORT = 49;
    public const int EXPR = 50;
    public const int EXTENDS = 51;
    public const int EscapeSequence = 52;
    public const int ExponentPart = 53;
    public const int FALSE = 54;
    public const int FF = 55;
    public const int FINAL = 56;
    public const int FINALLY = 57;
    public const int FLOAT = 58;
    public const int FOR = 59;
    public const int FORITER = 60;
    public const int FORSTEP = 61;
    public const int FUNCTION = 62;
    public const int GOTO = 63;
    public const int GT = 64;
    public const int GTE = 65;
    public const int HexDigit = 66;
    public const int HexEscapeSequence = 67;
    public const int HexIntegerLiteral = 68;
    public const int IF = 69;
    public const int IMPLEMENTS = 70;
    public const int IMPORT = 71;
    public const int IN = 72;
    public const int INC = 73;
    public const int INSTANCEOF = 74;
    public const int INT = 75;
    public const int INTERFACE = 76;
    public const int INV = 77;
    public const int ITEM = 78;
    public const int Identifier = 79;
    public const int IdentifierNameASCIIStart = 80;
    public const int IdentifierPart = 81;
    public const int IdentifierStartASCII = 82;
    public const int LABELLED = 83;
    public const int LAND = 84;
    public const int LBRACE = 85;
    public const int LBRACK = 86;
    public const int LF = 87;
    public const int LONG = 88;
    public const int LOR = 89;
    public const int LPAREN = 90;
    public const int LS = 91;
    public const int LT = 92;
    public const int LTE = 93;
    public const int LineTerminator = 94;
    public const int MOD = 95;
    public const int MODASS = 96;
    public const int MUL = 97;
    public const int MULASS = 98;
    public const int MultiLineComment = 99;
    public const int NAMEDVALUE = 100;
    public const int NATIVE = 101;
    public const int NBSP = 102;
    public const int NEG = 103;
    public const int NEQ = 104;
    public const int NEW = 105;
    public const int NOT = 106;
    public const int NSAME = 107;
    public const int NULL = 108;
    public const int OBJECT = 109;
    public const int OR = 110;
    public const int ORASS = 111;
    public const int OctalDigit = 112;
    public const int OctalEscapeSequence = 113;
    public const int OctalIntegerLiteral = 114;
    public const int PACKAGE = 115;
    public const int PAREXPR = 116;
    public const int PDEC = 117;
    public const int PINC = 118;
    public const int POS = 119;
    public const int PRIVATE = 120;
    public const int PROTECTED = 121;
    public const int PS = 122;
    public const int PUBLIC = 123;
    public const int QUE = 124;
    public const int RBRACE = 125;
    public const int RBRACK = 126;
    public const int RETURN = 127;
    public const int RPAREN = 128;
    public const int RegularExpressionChar = 129;
    public const int RegularExpressionFirstChar = 130;
    public const int RegularExpressionLiteral = 131;
    public const int SAME = 132;
    public const int SEMIC = 133;
    public const int SHL = 134;
    public const int SHLASS = 135;
    public const int SHORT = 136;
    public const int SHR = 137;
    public const int SHRASS = 138;
    public const int SHU = 139;
    public const int SHUASS = 140;
    public const int SP = 141;
    public const int SQUOTE = 142;
    public const int STATIC = 143;
    public const int SUB = 144;
    public const int SUBASS = 145;
    public const int SUPER = 146;
    public const int SWITCH = 147;
    public const int SYNCHRONIZED = 148;
    public const int SingleLineComment = 149;
    public const int StringLiteral = 150;
    public const int TAB = 151;
    public const int THIS = 152;
    public const int THROW = 153;
    public const int THROWS = 154;
    public const int TRANSIENT = 155;
    public const int TRUE = 156;
    public const int TRY = 157;
    public const int TYPEOF = 158;
    public const int USP = 159;
    public const int UnicodeEscapeSequence = 160;
    public const int VAR = 161;
    public const int VOID = 162;
    public const int VOLATILE = 163;
    public const int VT = 164;
    public const int WHILE = 165;
    public const int WITH = 166;
    public const int WhiteSpace = 167;
    public const int XOR = 168;
    public const int XORASS = 169;
    public const int ZeroToThree = 170;

    public ES3YUITestParser(ITokenStream input)
        : this(input, new RecognizerSharedState())
    {
    }
    public ES3YUITestParser(ITokenStream input, RecognizerSharedState state)
        : base(input, state)
    {
        OnCreated();
    }

    private StringTemplateGroup _templateGroup = new StringTemplateGroup("ES3YUITestParserTemplates", typeof(AngleBracketTemplateLexer));

    public StringTemplateGroup TemplateGroup
    {
        get { return _templateGroup; }
        set { _templateGroup = value; }
    }

    public override string[] TokenNames { get { return ES3YUITestParser.tokenNames; } }
    public override string GrammarFileName { get { return "ES3YUITest.g"; } }

    public bool Verbose { get; set; }
    public string SourceFileName { get; set; }

    private bool IsLeftHandSideAssign(TemplateParserRuleReturnScope<StringTemplate, IToken> lhs, object[] cached)
    {
        if (cached[0] != null)
        {
            return (bool)cached[0];
        }

        bool result;
        if (IsLeftHandSideExpression(lhs))
        {
            switch (input.LA(1))
            {
                case ASSIGN:
                case MULASS:
                case DIVASS:
                case MODASS:
                case ADDASS:
                case SUBASS:
                case SHLASS:
                case SHRASS:
                case SHUASS:
                case ANDASS:
                case XORASS:
                case ORASS:
                    result = true;
                    break;
                default:
                    result = false;
                    break;
            }
        }
        else
        {
            result = false;
        }

        cached[0] = result;
        return result;
    }

    private string WrapInBraces(IToken start, IToken stop, ITokenStream tokens)
    {
        if (start == null || stop == null)
        {
            return null;
        }

        if ("{" == start.Text)
        {
            return tokens.ToString(start, stop);
        }

        if (Verbose)
        {
            Console.WriteLine("\n[INFO] Adding braces around statement at line {0}", start.Line);
        }
        return "{" + tokens.ToString(start, stop) + "}";
    }

    private string ToObjectLiteral<T>(List<T> list, bool numbers)
    {
        var builder = new StringBuilder();
        builder.Append("{");
        for (int i = 0; i < list.Count; i++)
        {

            if (i > 0)
            {
                builder.Append(",");
            }

            if (numbers)
            {
                builder.Append('"');
                builder.Append(list[i]);
                builder.Append("\":0");
            }
            else
            {
                builder.Append(list[i]);
                builder.Append(":0");
            }
        }
        builder.Append("}");
        return builder.ToString();
    }

    private bool IsLeftHandSideExpression(TemplateParserRuleReturnScope<StringTemplate, IToken> lhs)
    {
        if (lhs.Start == null) // e.g. during backtracking
        {
            return true;
        }
        else
        {
            var tree = new CommonTree(lhs.Start);
            switch (tree.Type)
            {
                // primaryExpression
                case THIS:
                case Identifier:
                case NULL:
                case TRUE:
                case FALSE:
                case DecimalLiteral:
                case OctalIntegerLiteral:
                case HexIntegerLiteral:
                case StringLiteral:
                case RegularExpressionLiteral:
                case ARRAY:
                case OBJECT:
                case PAREXPR:
                // functionExpression
                case FUNCTION:
                // newExpression
                case NEW:
                // leftHandSideExpression
                case CALL:
                case BYFIELD:
                case BYINDEX:
                    return true;

                default:
                    return false;
            }
        }
    }

    private bool IsLeftHandSideIn(TemplateParserRuleReturnScope<StringTemplate, IToken> lhs, object[] cached)
    {
        if (cached[0] != null)
        {
            return (bool)cached[0];
        }

        var result = IsLeftHandSideExpression(lhs) && (input.LA(1) == IN);
        cached[0] = result;
        return result;
    }

    private void PromoteEOL(TemplateParserRuleReturnScope<StringTemplate, IToken> rule)
    {
        // Get current token and its type (the possibly offending token).
        var lt = input.LT(1);
        var la = lt.Type;

        // We only need to promote an EOL when the current token is offending (not a SEMIC, EOF, RBRACE, EOL or MultiLineComment).
        // EOL and MultiLineComment are not offending as they're already promoted in a previous call to this method.
        // Promoting an EOL means switching it from off channel to on channel.
        // A MultiLineComment gets promoted when it contains an EOL.
        if (!(la == SEMIC || la == EOF || la == RBRACE || la == EOL || la == MultiLineComment))
        {
            // Start on the possition before the current token and scan backwards off channel tokens until the previous on channel token.
            for (int ix = lt.TokenIndex - 1; ix > 0; ix--)
            {
                lt = input.Get(ix);
                if (lt.Channel == TokenChannels.Default)
                {
                    // On channel token found: stop scanning.
                    break;
                }

                if (lt.Type == EOL || (lt.Type == MultiLineComment && Regex.IsMatch(lt.Text, "/.*\r\n|\r|\n")))
                {
                    // We found our EOL: promote the token to on channel, position the input on it and reset the rule start.
                    lt.Channel = TokenChannels.Default;
                    input.Seek(lt.TokenIndex);
                    if (rule != null)
                    {
                        rule.Start = lt;
                    }
                    break;
                }
            }
        }
    }


    partial void OnCreated();
    partial void EnterRule(string ruleName, int ruleIndex);
    partial void LeaveRule(string ruleName, int ruleIndex);

    #region Rules
    partial void EnterRule_token();
    partial void LeaveRule_token();
    // $ANTLR start "token"
    // ES3YUITest.g:601:1: token : ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral );
    [GrammarRule("token")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> token()
    {
        EnterRule_token();
        EnterRule("token", 1);
        TraceIn("token", 1);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "token");
            DebugLocation(601, 1);
            try
            {
                // ES3YUITest.g:602:2: ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral )
                int alt1 = 5;
                try
                {
                    DebugEnterDecision(1, false);
                    switch (input.LA(1))
                    {
                        case ABSTRACT:
                        case BOOLEAN:
                        case BREAK:
                        case BYTE:
                        case CASE:
                        case CATCH:
                        case CHAR:
                        case CLASS:
                        case CONST:
                        case CONTINUE:
                        case DEBUGGER:
                        case DEFAULT:
                        case DELETE:
                        case DO:
                        case DOUBLE:
                        case ELSE:
                        case ENUM:
                        case EXPORT:
                        case EXTENDS:
                        case FALSE:
                        case FINAL:
                        case FINALLY:
                        case FLOAT:
                        case FOR:
                        case FUNCTION:
                        case GOTO:
                        case IF:
                        case IMPLEMENTS:
                        case IMPORT:
                        case IN:
                        case INSTANCEOF:
                        case INT:
                        case INTERFACE:
                        case LONG:
                        case NATIVE:
                        case NEW:
                        case NULL:
                        case PACKAGE:
                        case PRIVATE:
                        case PROTECTED:
                        case PUBLIC:
                        case RETURN:
                        case SHORT:
                        case STATIC:
                        case SUPER:
                        case SWITCH:
                        case SYNCHRONIZED:
                        case THIS:
                        case THROW:
                        case THROWS:
                        case TRANSIENT:
                        case TRUE:
                        case TRY:
                        case TYPEOF:
                        case VAR:
                        case VOID:
                        case VOLATILE:
                        case WHILE:
                        case WITH:
                            {
                                alt1 = 1;
                            }
                            break;
                        case Identifier:
                            {
                                alt1 = 2;
                            }
                            break;
                        case ADD:
                        case ADDASS:
                        case AND:
                        case ANDASS:
                        case ASSIGN:
                        case COLON:
                        case COMMA:
                        case DEC:
                        case DIV:
                        case DIVASS:
                        case DOT:
                        case EQ:
                        case GT:
                        case GTE:
                        case INC:
                        case INV:
                        case LAND:
                        case LBRACE:
                        case LBRACK:
                        case LOR:
                        case LPAREN:
                        case LT:
                        case LTE:
                        case MOD:
                        case MODASS:
                        case MUL:
                        case MULASS:
                        case NEQ:
                        case NOT:
                        case NSAME:
                        case OR:
                        case ORASS:
                        case QUE:
                        case RBRACE:
                        case RBRACK:
                        case RPAREN:
                        case SAME:
                        case SEMIC:
                        case SHL:
                        case SHLASS:
                        case SHR:
                        case SHRASS:
                        case SHU:
                        case SHUASS:
                        case SUB:
                        case SUBASS:
                        case XOR:
                        case XORASS:
                            {
                                alt1 = 3;
                            }
                            break;
                        case DecimalLiteral:
                        case HexIntegerLiteral:
                        case OctalIntegerLiteral:
                            {
                                alt1 = 4;
                            }
                            break;
                        case StringLiteral:
                            {
                                alt1 = 5;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(1); }
                switch (alt1)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:602:4: reservedWord
                        {
                            DebugLocation(602, 4);
                            PushFollow(Follow._reservedWord_in_token1763);
                            reservedWord();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:603:4: Identifier
                        {
                            DebugLocation(603, 4);
                            Match(input, Identifier, Follow._Identifier_in_token1768);

                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:604:4: punctuator
                        {
                            DebugLocation(604, 4);
                            PushFollow(Follow._punctuator_in_token1773);
                            punctuator();
                            PopFollow();


                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:605:4: numericLiteral
                        {
                            DebugLocation(605, 4);
                            PushFollow(Follow._numericLiteral_in_token1778);
                            numericLiteral();
                            PopFollow();


                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:606:4: StringLiteral
                        {
                            DebugLocation(606, 4);
                            Match(input, StringLiteral, Follow._StringLiteral_in_token1783);

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("token", 1);
                LeaveRule("token", 1);
                LeaveRule_token();
            }
            DebugLocation(607, 1);
        }
        finally { DebugExitRule(GrammarFileName, "token"); }
        return retval;

    }
    // $ANTLR end "token"

    partial void EnterRule_reservedWord();
    partial void LeaveRule_reservedWord();
    // $ANTLR start "reservedWord"
    // ES3YUITest.g:611:1: reservedWord : ( keyword | futureReservedWord | NULL | booleanLiteral );
    [GrammarRule("reservedWord")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> reservedWord()
    {
        EnterRule_reservedWord();
        EnterRule("reservedWord", 2);
        TraceIn("reservedWord", 2);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "reservedWord");
            DebugLocation(611, 1);
            try
            {
                // ES3YUITest.g:612:2: ( keyword | futureReservedWord | NULL | booleanLiteral )
                int alt2 = 4;
                try
                {
                    DebugEnterDecision(2, false);
                    switch (input.LA(1))
                    {
                        case BREAK:
                        case CASE:
                        case CATCH:
                        case CONTINUE:
                        case DEFAULT:
                        case DELETE:
                        case DO:
                        case ELSE:
                        case FINALLY:
                        case FOR:
                        case FUNCTION:
                        case IF:
                        case IN:
                        case INSTANCEOF:
                        case NEW:
                        case RETURN:
                        case SWITCH:
                        case THIS:
                        case THROW:
                        case TRY:
                        case TYPEOF:
                        case VAR:
                        case VOID:
                        case WHILE:
                        case WITH:
                            {
                                alt2 = 1;
                            }
                            break;
                        case ABSTRACT:
                        case BOOLEAN:
                        case BYTE:
                        case CHAR:
                        case CLASS:
                        case CONST:
                        case DEBUGGER:
                        case DOUBLE:
                        case ENUM:
                        case EXPORT:
                        case EXTENDS:
                        case FINAL:
                        case FLOAT:
                        case GOTO:
                        case IMPLEMENTS:
                        case IMPORT:
                        case INT:
                        case INTERFACE:
                        case LONG:
                        case NATIVE:
                        case PACKAGE:
                        case PRIVATE:
                        case PROTECTED:
                        case PUBLIC:
                        case SHORT:
                        case STATIC:
                        case SUPER:
                        case SYNCHRONIZED:
                        case THROWS:
                        case TRANSIENT:
                        case VOLATILE:
                            {
                                alt2 = 2;
                            }
                            break;
                        case NULL:
                            {
                                alt2 = 3;
                            }
                            break;
                        case FALSE:
                        case TRUE:
                            {
                                alt2 = 4;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(2); }
                switch (alt2)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:612:4: keyword
                        {
                            DebugLocation(612, 4);
                            PushFollow(Follow._keyword_in_reservedWord1796);
                            keyword();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:613:4: futureReservedWord
                        {
                            DebugLocation(613, 4);
                            PushFollow(Follow._futureReservedWord_in_reservedWord1801);
                            futureReservedWord();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:614:4: NULL
                        {
                            DebugLocation(614, 4);
                            Match(input, NULL, Follow._NULL_in_reservedWord1806);

                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:615:4: booleanLiteral
                        {
                            DebugLocation(615, 4);
                            PushFollow(Follow._booleanLiteral_in_reservedWord1811);
                            booleanLiteral();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("reservedWord", 2);
                LeaveRule("reservedWord", 2);
                LeaveRule_reservedWord();
            }
            DebugLocation(616, 1);
        }
        finally { DebugExitRule(GrammarFileName, "reservedWord"); }
        return retval;

    }
    // $ANTLR end "reservedWord"

    partial void EnterRule_keyword();
    partial void LeaveRule_keyword();
    // $ANTLR start "keyword"
    // ES3YUITest.g:622:1: keyword : ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH );
    [GrammarRule("keyword")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> keyword()
    {
        EnterRule_keyword();
        EnterRule("keyword", 3);
        TraceIn("keyword", 3);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "keyword");
            DebugLocation(622, 1);
            try
            {
                // ES3YUITest.g:623:2: ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(623, 2);
                    if (input.LA(1) == BREAK || (input.LA(1) >= CASE && input.LA(1) <= CATCH) || input.LA(1) == CONTINUE || (input.LA(1) >= DEFAULT && input.LA(1) <= DELETE) || input.LA(1) == DO || input.LA(1) == ELSE || input.LA(1) == FINALLY || input.LA(1) == FOR || input.LA(1) == FUNCTION || input.LA(1) == IF || input.LA(1) == IN || input.LA(1) == INSTANCEOF || input.LA(1) == NEW || input.LA(1) == RETURN || input.LA(1) == SWITCH || (input.LA(1) >= THIS && input.LA(1) <= THROW) || (input.LA(1) >= TRY && input.LA(1) <= TYPEOF) || (input.LA(1) >= VAR && input.LA(1) <= VOID) || (input.LA(1) >= WHILE && input.LA(1) <= WITH))
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("keyword", 3);
                LeaveRule("keyword", 3);
                LeaveRule_keyword();
            }
            DebugLocation(648, 1);
        }
        finally { DebugExitRule(GrammarFileName, "keyword"); }
        return retval;

    }
    // $ANTLR end "keyword"

    partial void EnterRule_futureReservedWord();
    partial void LeaveRule_futureReservedWord();
    // $ANTLR start "futureReservedWord"
    // ES3YUITest.g:654:1: futureReservedWord : ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE );
    [GrammarRule("futureReservedWord")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> futureReservedWord()
    {
        EnterRule_futureReservedWord();
        EnterRule("futureReservedWord", 4);
        TraceIn("futureReservedWord", 4);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "futureReservedWord");
            DebugLocation(654, 1);
            try
            {
                // ES3YUITest.g:655:2: ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(655, 2);
                    if (input.LA(1) == ABSTRACT || input.LA(1) == BOOLEAN || input.LA(1) == BYTE || (input.LA(1) >= CHAR && input.LA(1) <= CLASS) || input.LA(1) == CONST || input.LA(1) == DEBUGGER || input.LA(1) == DOUBLE || input.LA(1) == ENUM || input.LA(1) == EXPORT || input.LA(1) == EXTENDS || input.LA(1) == FINAL || input.LA(1) == FLOAT || input.LA(1) == GOTO || (input.LA(1) >= IMPLEMENTS && input.LA(1) <= IMPORT) || (input.LA(1) >= INT && input.LA(1) <= INTERFACE) || input.LA(1) == LONG || input.LA(1) == NATIVE || input.LA(1) == PACKAGE || (input.LA(1) >= PRIVATE && input.LA(1) <= PROTECTED) || input.LA(1) == PUBLIC || input.LA(1) == SHORT || input.LA(1) == STATIC || input.LA(1) == SUPER || input.LA(1) == SYNCHRONIZED || (input.LA(1) >= THROWS && input.LA(1) <= TRANSIENT) || input.LA(1) == VOLATILE)
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("futureReservedWord", 4);
                LeaveRule("futureReservedWord", 4);
                LeaveRule_futureReservedWord();
            }
            DebugLocation(686, 1);
        }
        finally { DebugExitRule(GrammarFileName, "futureReservedWord"); }
        return retval;

    }
    // $ANTLR end "futureReservedWord"

    partial void EnterRule_punctuator();
    partial void LeaveRule_punctuator();
    // $ANTLR start "punctuator"
    // ES3YUITest.g:732:1: punctuator : ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS );
    [GrammarRule("punctuator")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> punctuator()
    {
        EnterRule_punctuator();
        EnterRule("punctuator", 5);
        TraceIn("punctuator", 5);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "punctuator");
            DebugLocation(732, 1);
            try
            {
                // ES3YUITest.g:733:2: ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(733, 2);
                    if ((input.LA(1) >= ADD && input.LA(1) <= ANDASS) || input.LA(1) == ASSIGN || (input.LA(1) >= COLON && input.LA(1) <= COMMA) || input.LA(1) == DEC || (input.LA(1) >= DIV && input.LA(1) <= DIVASS) || input.LA(1) == DOT || input.LA(1) == EQ || (input.LA(1) >= GT && input.LA(1) <= GTE) || input.LA(1) == INC || input.LA(1) == INV || (input.LA(1) >= LAND && input.LA(1) <= LBRACK) || (input.LA(1) >= LOR && input.LA(1) <= LPAREN) || (input.LA(1) >= LT && input.LA(1) <= LTE) || (input.LA(1) >= MOD && input.LA(1) <= MULASS) || input.LA(1) == NEQ || (input.LA(1) >= NOT && input.LA(1) <= NSAME) || (input.LA(1) >= OR && input.LA(1) <= ORASS) || (input.LA(1) >= QUE && input.LA(1) <= RBRACK) || input.LA(1) == RPAREN || (input.LA(1) >= SAME && input.LA(1) <= SHLASS) || (input.LA(1) >= SHR && input.LA(1) <= SHUASS) || (input.LA(1) >= SUB && input.LA(1) <= SUBASS) || (input.LA(1) >= XOR && input.LA(1) <= XORASS))
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("punctuator", 5);
                LeaveRule("punctuator", 5);
                LeaveRule_punctuator();
            }
            DebugLocation(781, 1);
        }
        finally { DebugExitRule(GrammarFileName, "punctuator"); }
        return retval;

    }
    // $ANTLR end "punctuator"

    partial void EnterRule_literal();
    partial void LeaveRule_literal();
    // $ANTLR start "literal"
    // ES3YUITest.g:787:1: literal : ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral );
    [GrammarRule("literal")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> literal()
    {
        EnterRule_literal();
        EnterRule("literal", 6);
        TraceIn("literal", 6);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "literal");
            DebugLocation(787, 1);
            try
            {
                // ES3YUITest.g:788:2: ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral )
                int alt3 = 5;
                try
                {
                    DebugEnterDecision(3, false);
                    switch (input.LA(1))
                    {
                        case NULL:
                            {
                                alt3 = 1;
                            }
                            break;
                        case FALSE:
                        case TRUE:
                            {
                                alt3 = 2;
                            }
                            break;
                        case DecimalLiteral:
                        case HexIntegerLiteral:
                        case OctalIntegerLiteral:
                            {
                                alt3 = 3;
                            }
                            break;
                        case StringLiteral:
                            {
                                alt3 = 4;
                            }
                            break;
                        case RegularExpressionLiteral:
                            {
                                alt3 = 5;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(3); }
                switch (alt3)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:788:4: NULL
                        {
                            DebugLocation(788, 4);
                            Match(input, NULL, Follow._NULL_in_literal2492);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:789:4: booleanLiteral
                        {
                            DebugLocation(789, 4);
                            PushFollow(Follow._booleanLiteral_in_literal2497);
                            booleanLiteral();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:790:4: numericLiteral
                        {
                            DebugLocation(790, 4);
                            PushFollow(Follow._numericLiteral_in_literal2502);
                            numericLiteral();
                            PopFollow();


                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:791:4: StringLiteral
                        {
                            DebugLocation(791, 4);
                            Match(input, StringLiteral, Follow._StringLiteral_in_literal2507);

                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:792:4: RegularExpressionLiteral
                        {
                            DebugLocation(792, 4);
                            Match(input, RegularExpressionLiteral, Follow._RegularExpressionLiteral_in_literal2512);

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("literal", 6);
                LeaveRule("literal", 6);
                LeaveRule_literal();
            }
            DebugLocation(793, 1);
        }
        finally { DebugExitRule(GrammarFileName, "literal"); }
        return retval;

    }
    // $ANTLR end "literal"

    partial void EnterRule_booleanLiteral();
    partial void LeaveRule_booleanLiteral();
    // $ANTLR start "booleanLiteral"
    // ES3YUITest.g:795:1: booleanLiteral : ( TRUE | FALSE );
    [GrammarRule("booleanLiteral")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> booleanLiteral()
    {
        EnterRule_booleanLiteral();
        EnterRule("booleanLiteral", 7);
        TraceIn("booleanLiteral", 7);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "booleanLiteral");
            DebugLocation(795, 1);
            try
            {
                // ES3YUITest.g:796:2: ( TRUE | FALSE )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(796, 2);
                    if (input.LA(1) == FALSE || input.LA(1) == TRUE)
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("booleanLiteral", 7);
                LeaveRule("booleanLiteral", 7);
                LeaveRule_booleanLiteral();
            }
            DebugLocation(798, 1);
        }
        finally { DebugExitRule(GrammarFileName, "booleanLiteral"); }
        return retval;

    }
    // $ANTLR end "booleanLiteral"

    partial void EnterRule_numericLiteral();
    partial void LeaveRule_numericLiteral();
    // $ANTLR start "numericLiteral"
    // ES3YUITest.g:842:1: numericLiteral : ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral );
    [GrammarRule("numericLiteral")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> numericLiteral()
    {
        EnterRule_numericLiteral();
        EnterRule("numericLiteral", 8);
        TraceIn("numericLiteral", 8);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "numericLiteral");
            DebugLocation(842, 1);
            try
            {
                // ES3YUITest.g:843:2: ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(843, 2);
                    if (input.LA(1) == DecimalLiteral || input.LA(1) == HexIntegerLiteral || input.LA(1) == OctalIntegerLiteral)
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("numericLiteral", 8);
                LeaveRule("numericLiteral", 8);
                LeaveRule_numericLiteral();
            }
            DebugLocation(846, 1);
        }
        finally { DebugExitRule(GrammarFileName, "numericLiteral"); }
        return retval;

    }
    // $ANTLR end "numericLiteral"

    partial void EnterRule_primaryExpression();
    partial void LeaveRule_primaryExpression();
    // $ANTLR start "primaryExpression"
    // ES3YUITest.g:930:1: primaryExpression : ( THIS | Identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN );
    [GrammarRule("primaryExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> primaryExpression()
    {
        EnterRule_primaryExpression();
        EnterRule("primaryExpression", 9);
        TraceIn("primaryExpression", 9);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lpar = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "primaryExpression");
            DebugLocation(930, 1);
            try
            {
                // ES3YUITest.g:931:2: ( THIS | Identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN )
                int alt4 = 6;
                try
                {
                    DebugEnterDecision(4, false);
                    switch (input.LA(1))
                    {
                        case THIS:
                            {
                                alt4 = 1;
                            }
                            break;
                        case Identifier:
                            {
                                alt4 = 2;
                            }
                            break;
                        case DecimalLiteral:
                        case FALSE:
                        case HexIntegerLiteral:
                        case NULL:
                        case OctalIntegerLiteral:
                        case RegularExpressionLiteral:
                        case StringLiteral:
                        case TRUE:
                            {
                                alt4 = 3;
                            }
                            break;
                        case LBRACK:
                            {
                                alt4 = 4;
                            }
                            break;
                        case LBRACE:
                            {
                                alt4 = 5;
                            }
                            break;
                        case LPAREN:
                            {
                                alt4 = 6;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(4); }
                switch (alt4)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:931:4: THIS
                        {
                            DebugLocation(931, 4);
                            Match(input, THIS, Follow._THIS_in_primaryExpression3125);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:932:4: Identifier
                        {
                            DebugLocation(932, 4);
                            Match(input, Identifier, Follow._Identifier_in_primaryExpression3130);

                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:933:4: literal
                        {
                            DebugLocation(933, 4);
                            PushFollow(Follow._literal_in_primaryExpression3135);
                            literal();
                            PopFollow();


                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:934:4: arrayLiteral
                        {
                            DebugLocation(934, 4);
                            PushFollow(Follow._arrayLiteral_in_primaryExpression3140);
                            arrayLiteral();
                            PopFollow();


                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:935:4: objectLiteral
                        {
                            DebugLocation(935, 4);
                            PushFollow(Follow._objectLiteral_in_primaryExpression3145);
                            objectLiteral();
                            PopFollow();


                        }
                        break;
                    case 6:
                        DebugEnterAlt(6);
                        // ES3YUITest.g:936:4: lpar= LPAREN expression RPAREN
                        {
                            DebugLocation(936, 8);
                            lpar = (IToken)Match(input, LPAREN, Follow._LPAREN_in_primaryExpression3152);
                            DebugLocation(936, 16);
                            PushFollow(Follow._expression_in_primaryExpression3154);
                            expression();
                            PopFollow();

                            DebugLocation(936, 27);
                            Match(input, RPAREN, Follow._RPAREN_in_primaryExpression3156);

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("primaryExpression", 9);
                LeaveRule("primaryExpression", 9);
                LeaveRule_primaryExpression();
            }
            DebugLocation(937, 1);
        }
        finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
        return retval;

    }
    // $ANTLR end "primaryExpression"

    partial void EnterRule_arrayLiteral();
    partial void LeaveRule_arrayLiteral();
    // $ANTLR start "arrayLiteral"
    // ES3YUITest.g:942:1: arrayLiteral : lb= LBRACK ( arrayItem ( COMMA ( arrayItem )? )* )? RBRACK ;
    [GrammarRule("arrayLiteral")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> arrayLiteral()
    {
        EnterRule_arrayLiteral();
        EnterRule("arrayLiteral", 10);
        TraceIn("arrayLiteral", 10);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lb = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "arrayLiteral");
            DebugLocation(942, 1);
            try
            {
                // ES3YUITest.g:943:2: (lb= LBRACK ( arrayItem ( COMMA ( arrayItem )? )* )? RBRACK )
                DebugEnterAlt(1);
                // ES3YUITest.g:943:4: lb= LBRACK ( arrayItem ( COMMA ( arrayItem )? )* )? RBRACK
                {
                    DebugLocation(943, 6);
                    lb = (IToken)Match(input, LBRACK, Follow._LBRACK_in_arrayLiteral3172);
                    DebugLocation(943, 14);
                    // ES3YUITest.g:943:14: ( arrayItem ( COMMA ( arrayItem )? )* )?
                    int alt7 = 2;
                    try
                    {
                        DebugEnterSubRule(7);
                        try
                        {
                            DebugEnterDecision(7, false);
                            int LA7_1 = input.LA(1);

                            if ((LA7_1 == ADD || LA7_1 == COMMA || LA7_1 == DEC || LA7_1 == DELETE || LA7_1 == DecimalLiteral || LA7_1 == FALSE || LA7_1 == FUNCTION || LA7_1 == HexIntegerLiteral || LA7_1 == INC || LA7_1 == INV || LA7_1 == Identifier || (LA7_1 >= LBRACE && LA7_1 <= LBRACK) || LA7_1 == LPAREN || (LA7_1 >= NEW && LA7_1 <= NOT) || LA7_1 == NULL || LA7_1 == OctalIntegerLiteral || LA7_1 == RegularExpressionLiteral || LA7_1 == SUB || LA7_1 == StringLiteral || LA7_1 == THIS || LA7_1 == TRUE || LA7_1 == TYPEOF || LA7_1 == VOID))
                            {
                                alt7 = 1;
                            }
                            else if ((LA7_1 == RBRACK))
                            {
                                int LA7_2 = input.LA(2);

                                if (((input.LA(1) == COMMA)))
                                {
                                    alt7 = 1;
                                }
                            }
                        }
                        finally { DebugExitDecision(7); }
                        switch (alt7)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:943:16: arrayItem ( COMMA ( arrayItem )? )*
                                {
                                    DebugLocation(943, 16);
                                    PushFollow(Follow._arrayItem_in_arrayLiteral3176);
                                    arrayItem();
                                    PopFollow();

                                    DebugLocation(943, 26);
                                    // ES3YUITest.g:943:26: ( COMMA ( arrayItem )? )*
                                    try
                                    {
                                        DebugEnterSubRule(6);
                                        while (true)
                                        {
                                            int alt6 = 2;
                                            try
                                            {
                                                DebugEnterDecision(6, false);
                                                int LA6_1 = input.LA(1);

                                                if ((LA6_1 == COMMA))
                                                {
                                                    alt6 = 1;
                                                }


                                            }
                                            finally { DebugExitDecision(6); }
                                            switch (alt6)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:943:28: COMMA ( arrayItem )?
                                                    {
                                                        DebugLocation(943, 28);
                                                        Match(input, COMMA, Follow._COMMA_in_arrayLiteral3180);
                                                        DebugLocation(943, 34);
                                                        // ES3YUITest.g:943:34: ( arrayItem )?
                                                        int alt5 = 2;
                                                        try
                                                        {
                                                            DebugEnterSubRule(5);
                                                            try
                                                            {
                                                                DebugEnterDecision(5, false);
                                                                switch (input.LA(1))
                                                                {
                                                                    case ADD:
                                                                    case DEC:
                                                                    case DELETE:
                                                                    case DecimalLiteral:
                                                                    case FALSE:
                                                                    case FUNCTION:
                                                                    case HexIntegerLiteral:
                                                                    case INC:
                                                                    case INV:
                                                                    case Identifier:
                                                                    case LBRACE:
                                                                    case LBRACK:
                                                                    case LPAREN:
                                                                    case NEW:
                                                                    case NOT:
                                                                    case NULL:
                                                                    case OctalIntegerLiteral:
                                                                    case RegularExpressionLiteral:
                                                                    case SUB:
                                                                    case StringLiteral:
                                                                    case THIS:
                                                                    case TRUE:
                                                                    case TYPEOF:
                                                                    case VOID:
                                                                        {
                                                                            alt5 = 1;
                                                                        }
                                                                        break;
                                                                    case RBRACK:
                                                                        {
                                                                            int LA5_2 = input.LA(2);

                                                                            if (((input.LA(1) == COMMA)))
                                                                            {
                                                                                alt5 = 1;
                                                                            }
                                                                        }
                                                                        break;
                                                                    case COMMA:
                                                                        {
                                                                            int LA5_2 = input.LA(2);

                                                                            if (((input.LA(1) == COMMA)))
                                                                            {
                                                                                alt5 = 1;
                                                                            }
                                                                        }
                                                                        break;
                                                                }

                                                            }
                                                            finally { DebugExitDecision(5); }
                                                            switch (alt5)
                                                            {
                                                                case 1:
                                                                    DebugEnterAlt(1);
                                                                    // ES3YUITest.g:943:34: arrayItem
                                                                    {
                                                                        DebugLocation(943, 34);
                                                                        PushFollow(Follow._arrayItem_in_arrayLiteral3182);
                                                                        arrayItem();
                                                                        PopFollow();


                                                                    }
                                                                    break;

                                                            }
                                                        }
                                                        finally { DebugExitSubRule(5); }


                                                    }
                                                    break;

                                                default:
                                                    goto loop6;
                                            }
                                        }

                                    loop6:
                                        ;

                                    }
                                    finally { DebugExitSubRule(6); }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(7); }

                    DebugLocation(943, 51);
                    Match(input, RBRACK, Follow._RBRACK_in_arrayLiteral3191);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("arrayLiteral", 10);
                LeaveRule("arrayLiteral", 10);
                LeaveRule_arrayLiteral();
            }
            DebugLocation(945, 1);
        }
        finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
        return retval;

    }
    // $ANTLR end "arrayLiteral"

    partial void EnterRule_arrayItem();
    partial void LeaveRule_arrayItem();
    // $ANTLR start "arrayItem"
    // ES3YUITest.g:947:1: arrayItem : (expr= assignmentExpression |{...}?) ;
    [GrammarRule("arrayItem")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> arrayItem()
    {
        EnterRule_arrayItem();
        EnterRule("arrayItem", 11);
        TraceIn("arrayItem", 11);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> expr = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "arrayItem");
            DebugLocation(947, 1);
            try
            {
                // ES3YUITest.g:948:2: ( (expr= assignmentExpression |{...}?) )
                DebugEnterAlt(1);
                // ES3YUITest.g:948:4: (expr= assignmentExpression |{...}?)
                {
                    DebugLocation(948, 4);
                    // ES3YUITest.g:948:4: (expr= assignmentExpression |{...}?)
                    int alt8 = 2;
                    try
                    {
                        DebugEnterSubRule(8);
                        try
                        {
                            DebugEnterDecision(8, false);
                            int LA8_1 = input.LA(1);

                            if ((LA8_1 == ADD || LA8_1 == DEC || LA8_1 == DELETE || LA8_1 == DecimalLiteral || LA8_1 == FALSE || LA8_1 == FUNCTION || LA8_1 == HexIntegerLiteral || LA8_1 == INC || LA8_1 == INV || LA8_1 == Identifier || (LA8_1 >= LBRACE && LA8_1 <= LBRACK) || LA8_1 == LPAREN || (LA8_1 >= NEW && LA8_1 <= NOT) || LA8_1 == NULL || LA8_1 == OctalIntegerLiteral || LA8_1 == RegularExpressionLiteral || LA8_1 == SUB || LA8_1 == StringLiteral || LA8_1 == THIS || LA8_1 == TRUE || LA8_1 == TYPEOF || LA8_1 == VOID))
                            {
                                alt8 = 1;
                            }
                            else if ((LA8_1 == COMMA || LA8_1 == RBRACK))
                            {
                                alt8 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(8); }
                        switch (alt8)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:948:6: expr= assignmentExpression
                                {
                                    DebugLocation(948, 10);
                                    PushFollow(Follow._assignmentExpression_in_arrayItem3208);
                                    expr = assignmentExpression();
                                    PopFollow();


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // ES3YUITest.g:948:34: {...}?
                                {
                                    DebugLocation(948, 34);
                                    if (!((input.LA(1) == COMMA)))
                                    {
                                        throw new FailedPredicateException(input, "arrayItem", " input.LA(1) == COMMA ");
                                    }

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(8); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("arrayItem", 11);
                LeaveRule("arrayItem", 11);
                LeaveRule_arrayItem();
            }
            DebugLocation(950, 1);
        }
        finally { DebugExitRule(GrammarFileName, "arrayItem"); }
        return retval;

    }
    // $ANTLR end "arrayItem"

    partial void EnterRule_objectLiteral();
    partial void LeaveRule_objectLiteral();
    // $ANTLR start "objectLiteral"
    // ES3YUITest.g:952:1: objectLiteral : lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE ;
    [GrammarRule("objectLiteral")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> objectLiteral()
    {
        EnterRule_objectLiteral();
        EnterRule("objectLiteral", 12);
        TraceIn("objectLiteral", 12);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lb = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "objectLiteral");
            DebugLocation(952, 1);
            try
            {
                // ES3YUITest.g:953:2: (lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE )
                DebugEnterAlt(1);
                // ES3YUITest.g:953:4: lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE
                {
                    DebugLocation(953, 6);
                    lb = (IToken)Match(input, LBRACE, Follow._LBRACE_in_objectLiteral3229);
                    DebugLocation(953, 14);
                    // ES3YUITest.g:953:14: ( nameValuePair ( COMMA nameValuePair )* )?
                    int alt10 = 2;
                    try
                    {
                        DebugEnterSubRule(10);
                        try
                        {
                            DebugEnterDecision(10, false);
                            int LA10_1 = input.LA(1);

                            if ((LA10_1 == DecimalLiteral || LA10_1 == HexIntegerLiteral || LA10_1 == Identifier || LA10_1 == OctalIntegerLiteral || LA10_1 == StringLiteral))
                            {
                                alt10 = 1;
                            }
                        }
                        finally { DebugExitDecision(10); }
                        switch (alt10)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:953:16: nameValuePair ( COMMA nameValuePair )*
                                {
                                    DebugLocation(953, 16);
                                    PushFollow(Follow._nameValuePair_in_objectLiteral3233);
                                    nameValuePair();
                                    PopFollow();

                                    DebugLocation(953, 30);
                                    // ES3YUITest.g:953:30: ( COMMA nameValuePair )*
                                    try
                                    {
                                        DebugEnterSubRule(9);
                                        while (true)
                                        {
                                            int alt9 = 2;
                                            try
                                            {
                                                DebugEnterDecision(9, false);
                                                int LA9_1 = input.LA(1);

                                                if ((LA9_1 == COMMA))
                                                {
                                                    alt9 = 1;
                                                }


                                            }
                                            finally { DebugExitDecision(9); }
                                            switch (alt9)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:953:32: COMMA nameValuePair
                                                    {
                                                        DebugLocation(953, 32);
                                                        Match(input, COMMA, Follow._COMMA_in_objectLiteral3237);
                                                        DebugLocation(953, 38);
                                                        PushFollow(Follow._nameValuePair_in_objectLiteral3239);
                                                        nameValuePair();
                                                        PopFollow();


                                                    }
                                                    break;

                                                default:
                                                    goto loop9;
                                            }
                                        }

                                    loop9:
                                        ;

                                    }
                                    finally { DebugExitSubRule(9); }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(10); }

                    DebugLocation(953, 58);
                    Match(input, RBRACE, Follow._RBRACE_in_objectLiteral3247);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("objectLiteral", 12);
                LeaveRule("objectLiteral", 12);
                LeaveRule_objectLiteral();
            }
            DebugLocation(955, 1);
        }
        finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
        return retval;

    }
    // $ANTLR end "objectLiteral"

    partial void EnterRule_nameValuePair();
    partial void LeaveRule_nameValuePair();
    // $ANTLR start "nameValuePair"
    // ES3YUITest.g:961:1: nameValuePair : propertyName COLON assignmentExpression ;
    [GrammarRule("nameValuePair")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> nameValuePair()
    {
        EnterRule_nameValuePair();
        EnterRule("nameValuePair", 13);
        TraceIn("nameValuePair", 13);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "nameValuePair");
            DebugLocation(961, 1);
            try
            {
                // ES3YUITest.g:962:2: ( propertyName COLON assignmentExpression )
                DebugEnterAlt(1);
                // ES3YUITest.g:962:4: propertyName COLON assignmentExpression
                {
                    DebugLocation(962, 4);
                    PushFollow(Follow._propertyName_in_nameValuePair3263);
                    propertyName();
                    PopFollow();

                    DebugLocation(962, 17);
                    Match(input, COLON, Follow._COLON_in_nameValuePair3265);
                    DebugLocation(962, 23);
                    PushFollow(Follow._assignmentExpression_in_nameValuePair3267);
                    assignmentExpression();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("nameValuePair", 13);
                LeaveRule("nameValuePair", 13);
                LeaveRule_nameValuePair();
            }
            DebugLocation(964, 1);
        }
        finally { DebugExitRule(GrammarFileName, "nameValuePair"); }
        return retval;

    }
    // $ANTLR end "nameValuePair"

    partial void EnterRule_propertyName();
    partial void LeaveRule_propertyName();
    // $ANTLR start "propertyName"
    // ES3YUITest.g:966:1: propertyName : ( Identifier | StringLiteral | numericLiteral );
    [GrammarRule("propertyName")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> propertyName()
    {
        EnterRule_propertyName();
        EnterRule("propertyName", 14);
        TraceIn("propertyName", 14);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "propertyName");
            DebugLocation(966, 1);
            try
            {
                // ES3YUITest.g:967:2: ( Identifier | StringLiteral | numericLiteral )
                int alt11 = 3;
                try
                {
                    DebugEnterDecision(11, false);
                    switch (input.LA(1))
                    {
                        case Identifier:
                            {
                                alt11 = 1;
                            }
                            break;
                        case StringLiteral:
                            {
                                alt11 = 2;
                            }
                            break;
                        case DecimalLiteral:
                        case HexIntegerLiteral:
                        case OctalIntegerLiteral:
                            {
                                alt11 = 3;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(11); }
                switch (alt11)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:967:4: Identifier
                        {
                            DebugLocation(967, 4);
                            Match(input, Identifier, Follow._Identifier_in_propertyName3280);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:968:4: StringLiteral
                        {
                            DebugLocation(968, 4);
                            Match(input, StringLiteral, Follow._StringLiteral_in_propertyName3285);

                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:969:4: numericLiteral
                        {
                            DebugLocation(969, 4);
                            PushFollow(Follow._numericLiteral_in_propertyName3290);
                            numericLiteral();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("propertyName", 14);
                LeaveRule("propertyName", 14);
                LeaveRule_propertyName();
            }
            DebugLocation(970, 1);
        }
        finally { DebugExitRule(GrammarFileName, "propertyName"); }
        return retval;

    }
    // $ANTLR end "propertyName"

    partial void EnterRule_memberExpression();
    partial void LeaveRule_memberExpression();
    // $ANTLR start "memberExpression"
    // ES3YUITest.g:981:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
    [GrammarRule("memberExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> memberExpression()
    {
        EnterRule_memberExpression();
        EnterRule("memberExpression", 15);
        TraceIn("memberExpression", 15);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "memberExpression");
            DebugLocation(981, 1);
            try
            {
                // ES3YUITest.g:982:2: ( primaryExpression | functionExpression | newExpression )
                int alt12 = 3;
                try
                {
                    DebugEnterDecision(12, false);
                    switch (input.LA(1))
                    {
                        case DecimalLiteral:
                        case FALSE:
                        case HexIntegerLiteral:
                        case Identifier:
                        case LBRACE:
                        case LBRACK:
                        case LPAREN:
                        case NULL:
                        case OctalIntegerLiteral:
                        case RegularExpressionLiteral:
                        case StringLiteral:
                        case THIS:
                        case TRUE:
                            {
                                alt12 = 1;
                            }
                            break;
                        case FUNCTION:
                            {
                                alt12 = 2;
                            }
                            break;
                        case NEW:
                            {
                                alt12 = 3;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(12); }
                switch (alt12)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:982:4: primaryExpression
                        {
                            DebugLocation(982, 4);
                            PushFollow(Follow._primaryExpression_in_memberExpression3308);
                            primaryExpression();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:983:4: functionExpression
                        {
                            DebugLocation(983, 4);
                            PushFollow(Follow._functionExpression_in_memberExpression3313);
                            functionExpression();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:984:4: newExpression
                        {
                            DebugLocation(984, 4);
                            PushFollow(Follow._newExpression_in_memberExpression3318);
                            newExpression();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("memberExpression", 15);
                LeaveRule("memberExpression", 15);
                LeaveRule_memberExpression();
            }
            DebugLocation(985, 1);
        }
        finally { DebugExitRule(GrammarFileName, "memberExpression"); }
        return retval;

    }
    // $ANTLR end "memberExpression"

    partial void EnterRule_newExpression();
    partial void LeaveRule_newExpression();
    // $ANTLR start "newExpression"
    // ES3YUITest.g:987:1: newExpression : ( NEW primaryExpression | NEW functionExpression );
    [GrammarRule("newExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> newExpression()
    {
        EnterRule_newExpression();
        EnterRule("newExpression", 16);
        TraceIn("newExpression", 16);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "newExpression");
            DebugLocation(987, 1);
            try
            {
                // ES3YUITest.g:988:2: ( NEW primaryExpression | NEW functionExpression )
                int alt13 = 2;
                try
                {
                    DebugEnterDecision(13, false);
                    int LA13_1 = input.LA(1);

                    if ((LA13_1 == NEW))
                    {
                        int LA13_2 = input.LA(2);

                        if ((LA13_2 == DecimalLiteral || LA13_2 == FALSE || LA13_2 == HexIntegerLiteral || LA13_2 == Identifier || (LA13_2 >= LBRACE && LA13_2 <= LBRACK) || LA13_2 == LPAREN || LA13_2 == NULL || LA13_2 == OctalIntegerLiteral || LA13_2 == RegularExpressionLiteral || LA13_2 == StringLiteral || LA13_2 == THIS || LA13_2 == TRUE))
                        {
                            alt13 = 1;
                        }
                        else if ((LA13_2 == FUNCTION))
                        {
                            alt13 = 2;
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 13, 1, input, 2);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(13); }
                switch (alt13)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:988:4: NEW primaryExpression
                        {
                            DebugLocation(988, 4);
                            Match(input, NEW, Follow._NEW_in_newExpression3329);
                            DebugLocation(988, 8);
                            PushFollow(Follow._primaryExpression_in_newExpression3331);
                            primaryExpression();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:989:11: NEW functionExpression
                        {
                            DebugLocation(989, 11);
                            Match(input, NEW, Follow._NEW_in_newExpression3343);
                            DebugLocation(989, 15);
                            PushFollow(Follow._functionExpression_in_newExpression3345);
                            functionExpression();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("newExpression", 16);
                LeaveRule("newExpression", 16);
                LeaveRule_newExpression();
            }
            DebugLocation(990, 1);
        }
        finally { DebugExitRule(GrammarFileName, "newExpression"); }
        return retval;

    }
    // $ANTLR end "newExpression"

    partial void EnterRule_arguments();
    partial void LeaveRule_arguments();
    // $ANTLR start "arguments"
    // ES3YUITest.g:993:1: arguments : LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN ;
    [GrammarRule("arguments")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> arguments()
    {
        EnterRule_arguments();
        EnterRule("arguments", 17);
        TraceIn("arguments", 17);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "arguments");
            DebugLocation(993, 1);
            try
            {
                // ES3YUITest.g:994:2: ( LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN )
                DebugEnterAlt(1);
                // ES3YUITest.g:994:4: LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN
                {
                    DebugLocation(994, 4);
                    Match(input, LPAREN, Follow._LPAREN_in_arguments3361);
                    DebugLocation(994, 11);
                    // ES3YUITest.g:994:11: ( assignmentExpression ( COMMA assignmentExpression )* )?
                    int alt15 = 2;
                    try
                    {
                        DebugEnterSubRule(15);
                        try
                        {
                            DebugEnterDecision(15, false);
                            int LA15_1 = input.LA(1);

                            if ((LA15_1 == ADD || LA15_1 == DEC || LA15_1 == DELETE || LA15_1 == DecimalLiteral || LA15_1 == FALSE || LA15_1 == FUNCTION || LA15_1 == HexIntegerLiteral || LA15_1 == INC || LA15_1 == INV || LA15_1 == Identifier || (LA15_1 >= LBRACE && LA15_1 <= LBRACK) || LA15_1 == LPAREN || (LA15_1 >= NEW && LA15_1 <= NOT) || LA15_1 == NULL || LA15_1 == OctalIntegerLiteral || LA15_1 == RegularExpressionLiteral || LA15_1 == SUB || LA15_1 == StringLiteral || LA15_1 == THIS || LA15_1 == TRUE || LA15_1 == TYPEOF || LA15_1 == VOID))
                            {
                                alt15 = 1;
                            }
                        }
                        finally { DebugExitDecision(15); }
                        switch (alt15)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:994:13: assignmentExpression ( COMMA assignmentExpression )*
                                {
                                    DebugLocation(994, 13);
                                    PushFollow(Follow._assignmentExpression_in_arguments3365);
                                    assignmentExpression();
                                    PopFollow();

                                    DebugLocation(994, 34);
                                    // ES3YUITest.g:994:34: ( COMMA assignmentExpression )*
                                    try
                                    {
                                        DebugEnterSubRule(14);
                                        while (true)
                                        {
                                            int alt14 = 2;
                                            try
                                            {
                                                DebugEnterDecision(14, false);
                                                int LA14_1 = input.LA(1);

                                                if ((LA14_1 == COMMA))
                                                {
                                                    alt14 = 1;
                                                }


                                            }
                                            finally { DebugExitDecision(14); }
                                            switch (alt14)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:994:36: COMMA assignmentExpression
                                                    {
                                                        DebugLocation(994, 36);
                                                        Match(input, COMMA, Follow._COMMA_in_arguments3369);
                                                        DebugLocation(994, 42);
                                                        PushFollow(Follow._assignmentExpression_in_arguments3371);
                                                        assignmentExpression();
                                                        PopFollow();


                                                    }
                                                    break;

                                                default:
                                                    goto loop14;
                                            }
                                        }

                                    loop14:
                                        ;

                                    }
                                    finally { DebugExitSubRule(14); }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(15); }

                    DebugLocation(994, 69);
                    Match(input, RPAREN, Follow._RPAREN_in_arguments3379);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("arguments", 17);
                LeaveRule("arguments", 17);
                LeaveRule_arguments();
            }
            DebugLocation(996, 1);
        }
        finally { DebugExitRule(GrammarFileName, "arguments"); }
        return retval;

    }
    // $ANTLR end "arguments"

    partial void EnterRule_leftHandSideExpression();
    partial void LeaveRule_leftHandSideExpression();
    // $ANTLR start "leftHandSideExpression"
    // ES3YUITest.g:998:1: leftHandSideExpression : ( memberExpression ) ( arguments | LBRACK expression RBRACK | DOT Identifier )* ;
    [GrammarRule("leftHandSideExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> leftHandSideExpression()
    {
        EnterRule_leftHandSideExpression();
        EnterRule("leftHandSideExpression", 18);
        TraceIn("leftHandSideExpression", 18);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "leftHandSideExpression");
            DebugLocation(998, 1);
            try
            {
                // ES3YUITest.g:999:2: ( ( memberExpression ) ( arguments | LBRACK expression RBRACK | DOT Identifier )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1000:2: ( memberExpression ) ( arguments | LBRACK expression RBRACK | DOT Identifier )*
                {
                    DebugLocation(1000, 2);
                    // ES3YUITest.g:1000:2: ( memberExpression )
                    DebugEnterAlt(1);
                    // ES3YUITest.g:1001:3: memberExpression
                    {
                        DebugLocation(1001, 3);
                        PushFollow(Follow._memberExpression_in_leftHandSideExpression3398);
                        memberExpression();
                        PopFollow();


                    }

                    DebugLocation(1003, 2);
                    // ES3YUITest.g:1003:2: ( arguments | LBRACK expression RBRACK | DOT Identifier )*
                    try
                    {
                        DebugEnterSubRule(16);
                        while (true)
                        {
                            int alt16 = 4;
                            try
                            {
                                DebugEnterDecision(16, false);
                                switch (input.LA(1))
                                {
                                    case LPAREN:
                                        {
                                            alt16 = 1;
                                        }
                                        break;
                                    case LBRACK:
                                        {
                                            alt16 = 2;
                                        }
                                        break;
                                    case DOT:
                                        {
                                            alt16 = 3;
                                        }
                                        break;
                                }

                            }
                            finally { DebugExitDecision(16); }
                            switch (alt16)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1004:3: arguments
                                    {
                                        DebugLocation(1004, 3);
                                        PushFollow(Follow._arguments_in_leftHandSideExpression3411);
                                        arguments();
                                        PopFollow();


                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // ES3YUITest.g:1005:5: LBRACK expression RBRACK
                                    {
                                        DebugLocation(1005, 5);
                                        Match(input, LBRACK, Follow._LBRACK_in_leftHandSideExpression3420);
                                        DebugLocation(1005, 12);
                                        PushFollow(Follow._expression_in_leftHandSideExpression3422);
                                        expression();
                                        PopFollow();

                                        DebugLocation(1005, 23);
                                        Match(input, RBRACK, Follow._RBRACK_in_leftHandSideExpression3424);

                                    }
                                    break;
                                case 3:
                                    DebugEnterAlt(3);
                                    // ES3YUITest.g:1006:5: DOT Identifier
                                    {
                                        DebugLocation(1006, 5);
                                        Match(input, DOT, Follow._DOT_in_leftHandSideExpression3431);
                                        DebugLocation(1006, 9);
                                        Match(input, Identifier, Follow._Identifier_in_leftHandSideExpression3433);

                                    }
                                    break;

                                default:
                                    goto loop16;
                            }
                        }

                    loop16:
                        ;

                    }
                    finally { DebugExitSubRule(16); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("leftHandSideExpression", 18);
                LeaveRule("leftHandSideExpression", 18);
                LeaveRule_leftHandSideExpression();
            }
            DebugLocation(1008, 1);
        }
        finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
        return retval;

    }
    // $ANTLR end "leftHandSideExpression"

    partial void EnterRule_postfixExpression();
    partial void LeaveRule_postfixExpression();
    // $ANTLR start "postfixExpression"
    // ES3YUITest.g:1020:1: postfixExpression : leftHandSideExpression ( postfixOperator )? ;
    [GrammarRule("postfixExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> postfixExpression()
    {
        EnterRule_postfixExpression();
        EnterRule("postfixExpression", 19);
        TraceIn("postfixExpression", 19);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "postfixExpression");
            DebugLocation(1020, 1);
            try
            {
                // ES3YUITest.g:1021:2: ( leftHandSideExpression ( postfixOperator )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1021:4: leftHandSideExpression ( postfixOperator )?
                {
                    DebugLocation(1021, 4);
                    PushFollow(Follow._leftHandSideExpression_in_postfixExpression3456);
                    leftHandSideExpression();
                    PopFollow();

                    DebugLocation(1021, 27);
                    if (input.LA(1) == INC || input.LA(1) == DEC) PromoteEOL(null);
                    DebugLocation(1021, 95);
                    // ES3YUITest.g:1021:95: ( postfixOperator )?
                    int alt17 = 2;
                    try
                    {
                        DebugEnterSubRule(17);
                        try
                        {
                            DebugEnterDecision(17, false);
                            int LA17_1 = input.LA(1);

                            if ((LA17_1 == DEC || LA17_1 == INC))
                            {
                                alt17 = 1;
                            }
                        }
                        finally { DebugExitDecision(17); }
                        switch (alt17)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1021:97: postfixOperator
                                {
                                    DebugLocation(1021, 97);
                                    PushFollow(Follow._postfixOperator_in_postfixExpression3462);
                                    postfixOperator();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(17); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("postfixExpression", 19);
                LeaveRule("postfixExpression", 19);
                LeaveRule_postfixExpression();
            }
            DebugLocation(1022, 1);
        }
        finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
        return retval;

    }
    // $ANTLR end "postfixExpression"

    partial void EnterRule_postfixOperator();
    partial void LeaveRule_postfixOperator();
    // $ANTLR start "postfixOperator"
    // ES3YUITest.g:1024:1: postfixOperator : (op= INC |op= DEC );
    [GrammarRule("postfixOperator")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> postfixOperator()
    {
        EnterRule_postfixOperator();
        EnterRule("postfixOperator", 20);
        TraceIn("postfixOperator", 20);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken op = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "postfixOperator");
            DebugLocation(1024, 1);
            try
            {
                // ES3YUITest.g:1025:2: (op= INC |op= DEC )
                int alt18 = 2;
                try
                {
                    DebugEnterDecision(18, false);
                    int LA18_1 = input.LA(1);

                    if ((LA18_1 == INC))
                    {
                        alt18 = 1;
                    }
                    else if ((LA18_1 == DEC))
                    {
                        alt18 = 2;
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(18); }
                switch (alt18)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1025:4: op= INC
                        {
                            DebugLocation(1025, 6);
                            op = (IToken)Match(input, INC, Follow._INC_in_postfixOperator3479);
                            DebugLocation(1025, 11);
                            op.Type = PINC;

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1026:4: op= DEC
                        {
                            DebugLocation(1026, 6);
                            op = (IToken)Match(input, DEC, Follow._DEC_in_postfixOperator3488);
                            DebugLocation(1026, 11);
                            op.Type = PDEC;

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("postfixOperator", 20);
                LeaveRule("postfixOperator", 20);
                LeaveRule_postfixOperator();
            }
            DebugLocation(1027, 1);
        }
        finally { DebugExitRule(GrammarFileName, "postfixOperator"); }
        return retval;

    }
    // $ANTLR end "postfixOperator"

    partial void EnterRule_unaryExpression();
    partial void LeaveRule_unaryExpression();
    // $ANTLR start "unaryExpression"
    // ES3YUITest.g:1033:1: unaryExpression : ( postfixExpression | unaryOperator unaryExpression );
    [GrammarRule("unaryExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> unaryExpression()
    {
        EnterRule_unaryExpression();
        EnterRule("unaryExpression", 21);
        TraceIn("unaryExpression", 21);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "unaryExpression");
            DebugLocation(1033, 1);
            try
            {
                // ES3YUITest.g:1034:2: ( postfixExpression | unaryOperator unaryExpression )
                int alt19 = 2;
                try
                {
                    DebugEnterDecision(19, false);
                    int LA19_1 = input.LA(1);

                    if ((LA19_1 == DecimalLiteral || LA19_1 == FALSE || LA19_1 == FUNCTION || LA19_1 == HexIntegerLiteral || LA19_1 == Identifier || (LA19_1 >= LBRACE && LA19_1 <= LBRACK) || LA19_1 == LPAREN || LA19_1 == NEW || LA19_1 == NULL || LA19_1 == OctalIntegerLiteral || LA19_1 == RegularExpressionLiteral || LA19_1 == StringLiteral || LA19_1 == THIS || LA19_1 == TRUE))
                    {
                        alt19 = 1;
                    }
                    else if ((LA19_1 == ADD || LA19_1 == DEC || LA19_1 == DELETE || LA19_1 == INC || LA19_1 == INV || LA19_1 == NOT || LA19_1 == SUB || LA19_1 == TYPEOF || LA19_1 == VOID))
                    {
                        alt19 = 2;
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(19); }
                switch (alt19)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1034:4: postfixExpression
                        {
                            DebugLocation(1034, 4);
                            PushFollow(Follow._postfixExpression_in_unaryExpression3505);
                            postfixExpression();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1035:4: unaryOperator unaryExpression
                        {
                            DebugLocation(1035, 4);
                            PushFollow(Follow._unaryOperator_in_unaryExpression3510);
                            unaryOperator();
                            PopFollow();

                            DebugLocation(1035, 18);
                            PushFollow(Follow._unaryExpression_in_unaryExpression3512);
                            unaryExpression();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("unaryExpression", 21);
                LeaveRule("unaryExpression", 21);
                LeaveRule_unaryExpression();
            }
            DebugLocation(1036, 1);
        }
        finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
        return retval;

    }
    // $ANTLR end "unaryExpression"

    partial void EnterRule_unaryOperator();
    partial void LeaveRule_unaryOperator();
    // $ANTLR start "unaryOperator"
    // ES3YUITest.g:1038:1: unaryOperator : ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT );
    [GrammarRule("unaryOperator")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> unaryOperator()
    {
        EnterRule_unaryOperator();
        EnterRule("unaryOperator", 22);
        TraceIn("unaryOperator", 22);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken op = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "unaryOperator");
            DebugLocation(1038, 1);
            try
            {
                // ES3YUITest.g:1039:2: ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT )
                int alt20 = 9;
                try
                {
                    DebugEnterDecision(20, false);
                    switch (input.LA(1))
                    {
                        case DELETE:
                            {
                                alt20 = 1;
                            }
                            break;
                        case VOID:
                            {
                                alt20 = 2;
                            }
                            break;
                        case TYPEOF:
                            {
                                alt20 = 3;
                            }
                            break;
                        case INC:
                            {
                                alt20 = 4;
                            }
                            break;
                        case DEC:
                            {
                                alt20 = 5;
                            }
                            break;
                        case ADD:
                            {
                                alt20 = 6;
                            }
                            break;
                        case SUB:
                            {
                                alt20 = 7;
                            }
                            break;
                        case INV:
                            {
                                alt20 = 8;
                            }
                            break;
                        case NOT:
                            {
                                alt20 = 9;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(20); }
                switch (alt20)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1039:4: DELETE
                        {
                            DebugLocation(1039, 4);
                            Match(input, DELETE, Follow._DELETE_in_unaryOperator3524);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1040:4: VOID
                        {
                            DebugLocation(1040, 4);
                            Match(input, VOID, Follow._VOID_in_unaryOperator3529);

                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:1041:4: TYPEOF
                        {
                            DebugLocation(1041, 4);
                            Match(input, TYPEOF, Follow._TYPEOF_in_unaryOperator3534);

                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:1042:4: INC
                        {
                            DebugLocation(1042, 4);
                            Match(input, INC, Follow._INC_in_unaryOperator3539);

                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:1043:4: DEC
                        {
                            DebugLocation(1043, 4);
                            Match(input, DEC, Follow._DEC_in_unaryOperator3544);

                        }
                        break;
                    case 6:
                        DebugEnterAlt(6);
                        // ES3YUITest.g:1044:4: op= ADD
                        {
                            DebugLocation(1044, 6);
                            op = (IToken)Match(input, ADD, Follow._ADD_in_unaryOperator3551);
                            DebugLocation(1044, 11);
                            op.Type = POS;

                        }
                        break;
                    case 7:
                        DebugEnterAlt(7);
                        // ES3YUITest.g:1045:4: op= SUB
                        {
                            DebugLocation(1045, 6);
                            op = (IToken)Match(input, SUB, Follow._SUB_in_unaryOperator3560);
                            DebugLocation(1045, 11);
                            op.Type = NEG;

                        }
                        break;
                    case 8:
                        DebugEnterAlt(8);
                        // ES3YUITest.g:1046:4: INV
                        {
                            DebugLocation(1046, 4);
                            Match(input, INV, Follow._INV_in_unaryOperator3567);

                        }
                        break;
                    case 9:
                        DebugEnterAlt(9);
                        // ES3YUITest.g:1047:4: NOT
                        {
                            DebugLocation(1047, 4);
                            Match(input, NOT, Follow._NOT_in_unaryOperator3572);

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("unaryOperator", 22);
                LeaveRule("unaryOperator", 22);
                LeaveRule_unaryOperator();
            }
            DebugLocation(1048, 1);
        }
        finally { DebugExitRule(GrammarFileName, "unaryOperator"); }
        return retval;

    }
    // $ANTLR end "unaryOperator"

    partial void EnterRule_multiplicativeExpression();
    partial void LeaveRule_multiplicativeExpression();
    // $ANTLR start "multiplicativeExpression"
    // ES3YUITest.g:1054:1: multiplicativeExpression : unaryExpression ( ( MUL | DIV | MOD ) unaryExpression )* ;
    [GrammarRule("multiplicativeExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> multiplicativeExpression()
    {
        EnterRule_multiplicativeExpression();
        EnterRule("multiplicativeExpression", 23);
        TraceIn("multiplicativeExpression", 23);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "multiplicativeExpression");
            DebugLocation(1054, 1);
            try
            {
                // ES3YUITest.g:1055:2: ( unaryExpression ( ( MUL | DIV | MOD ) unaryExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1055:4: unaryExpression ( ( MUL | DIV | MOD ) unaryExpression )*
                {
                    DebugLocation(1055, 4);
                    PushFollow(Follow._unaryExpression_in_multiplicativeExpression3587);
                    unaryExpression();
                    PopFollow();

                    DebugLocation(1055, 20);
                    // ES3YUITest.g:1055:20: ( ( MUL | DIV | MOD ) unaryExpression )*
                    try
                    {
                        DebugEnterSubRule(21);
                        while (true)
                        {
                            int alt21 = 2;
                            try
                            {
                                DebugEnterDecision(21, false);
                                int LA21_1 = input.LA(1);

                                if ((LA21_1 == DIV || LA21_1 == MOD || LA21_1 == MUL))
                                {
                                    alt21 = 1;
                                }


                            }
                            finally { DebugExitDecision(21); }
                            switch (alt21)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1055:22: ( MUL | DIV | MOD ) unaryExpression
                                    {
                                        DebugLocation(1055, 22);
                                        if (input.LA(1) == DIV || input.LA(1) == MOD || input.LA(1) == MUL)
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1055, 42);
                                        PushFollow(Follow._unaryExpression_in_multiplicativeExpression3605);
                                        unaryExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop21;
                            }
                        }

                    loop21:
                        ;

                    }
                    finally { DebugExitSubRule(21); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("multiplicativeExpression", 23);
                LeaveRule("multiplicativeExpression", 23);
                LeaveRule_multiplicativeExpression();
            }
            DebugLocation(1056, 1);
        }
        finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
        return retval;

    }
    // $ANTLR end "multiplicativeExpression"

    partial void EnterRule_additiveExpression();
    partial void LeaveRule_additiveExpression();
    // $ANTLR start "additiveExpression"
    // ES3YUITest.g:1062:1: additiveExpression : multiplicativeExpression ( ( ADD | SUB ) multiplicativeExpression )* ;
    [GrammarRule("additiveExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> additiveExpression()
    {
        EnterRule_additiveExpression();
        EnterRule("additiveExpression", 24);
        TraceIn("additiveExpression", 24);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "additiveExpression");
            DebugLocation(1062, 1);
            try
            {
                // ES3YUITest.g:1063:2: ( multiplicativeExpression ( ( ADD | SUB ) multiplicativeExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1063:4: multiplicativeExpression ( ( ADD | SUB ) multiplicativeExpression )*
                {
                    DebugLocation(1063, 4);
                    PushFollow(Follow._multiplicativeExpression_in_additiveExpression3623);
                    multiplicativeExpression();
                    PopFollow();

                    DebugLocation(1063, 29);
                    // ES3YUITest.g:1063:29: ( ( ADD | SUB ) multiplicativeExpression )*
                    try
                    {
                        DebugEnterSubRule(22);
                        while (true)
                        {
                            int alt22 = 2;
                            try
                            {
                                DebugEnterDecision(22, false);
                                int LA22_1 = input.LA(1);

                                if ((LA22_1 == ADD || LA22_1 == SUB))
                                {
                                    alt22 = 1;
                                }


                            }
                            finally { DebugExitDecision(22); }
                            switch (alt22)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1063:31: ( ADD | SUB ) multiplicativeExpression
                                    {
                                        DebugLocation(1063, 31);
                                        if (input.LA(1) == ADD || input.LA(1) == SUB)
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1063, 45);
                                        PushFollow(Follow._multiplicativeExpression_in_additiveExpression3637);
                                        multiplicativeExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop22;
                            }
                        }

                    loop22:
                        ;

                    }
                    finally { DebugExitSubRule(22); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("additiveExpression", 24);
                LeaveRule("additiveExpression", 24);
                LeaveRule_additiveExpression();
            }
            DebugLocation(1064, 1);
        }
        finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
        return retval;

    }
    // $ANTLR end "additiveExpression"

    partial void EnterRule_shiftExpression();
    partial void LeaveRule_shiftExpression();
    // $ANTLR start "shiftExpression"
    // ES3YUITest.g:1070:1: shiftExpression : additiveExpression ( ( SHL | SHR | SHU ) additiveExpression )* ;
    [GrammarRule("shiftExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> shiftExpression()
    {
        EnterRule_shiftExpression();
        EnterRule("shiftExpression", 25);
        TraceIn("shiftExpression", 25);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "shiftExpression");
            DebugLocation(1070, 1);
            try
            {
                // ES3YUITest.g:1071:2: ( additiveExpression ( ( SHL | SHR | SHU ) additiveExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1071:4: additiveExpression ( ( SHL | SHR | SHU ) additiveExpression )*
                {
                    DebugLocation(1071, 4);
                    PushFollow(Follow._additiveExpression_in_shiftExpression3656);
                    additiveExpression();
                    PopFollow();

                    DebugLocation(1071, 23);
                    // ES3YUITest.g:1071:23: ( ( SHL | SHR | SHU ) additiveExpression )*
                    try
                    {
                        DebugEnterSubRule(23);
                        while (true)
                        {
                            int alt23 = 2;
                            try
                            {
                                DebugEnterDecision(23, false);
                                int LA23_1 = input.LA(1);

                                if ((LA23_1 == SHL || LA23_1 == SHR || LA23_1 == SHU))
                                {
                                    alt23 = 1;
                                }


                            }
                            finally { DebugExitDecision(23); }
                            switch (alt23)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1071:25: ( SHL | SHR | SHU ) additiveExpression
                                    {
                                        DebugLocation(1071, 25);
                                        if (input.LA(1) == SHL || input.LA(1) == SHR || input.LA(1) == SHU)
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1071, 45);
                                        PushFollow(Follow._additiveExpression_in_shiftExpression3674);
                                        additiveExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop23;
                            }
                        }

                    loop23:
                        ;

                    }
                    finally { DebugExitSubRule(23); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("shiftExpression", 25);
                LeaveRule("shiftExpression", 25);
                LeaveRule_shiftExpression();
            }
            DebugLocation(1072, 1);
        }
        finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
        return retval;

    }
    // $ANTLR end "shiftExpression"

    partial void EnterRule_relationalExpression();
    partial void LeaveRule_relationalExpression();
    // $ANTLR start "relationalExpression"
    // ES3YUITest.g:1078:1: relationalExpression : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) shiftExpression )* ;
    [GrammarRule("relationalExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> relationalExpression()
    {
        EnterRule_relationalExpression();
        EnterRule("relationalExpression", 26);
        TraceIn("relationalExpression", 26);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "relationalExpression");
            DebugLocation(1078, 1);
            try
            {
                // ES3YUITest.g:1079:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) shiftExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1079:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) shiftExpression )*
                {
                    DebugLocation(1079, 4);
                    PushFollow(Follow._shiftExpression_in_relationalExpression3693);
                    shiftExpression();
                    PopFollow();

                    DebugLocation(1079, 20);
                    // ES3YUITest.g:1079:20: ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) shiftExpression )*
                    try
                    {
                        DebugEnterSubRule(24);
                        while (true)
                        {
                            int alt24 = 2;
                            try
                            {
                                DebugEnterDecision(24, false);
                                int LA24_1 = input.LA(1);

                                if (((LA24_1 >= GT && LA24_1 <= GTE) || LA24_1 == IN || LA24_1 == INSTANCEOF || (LA24_1 >= LT && LA24_1 <= LTE)))
                                {
                                    alt24 = 1;
                                }


                            }
                            finally { DebugExitDecision(24); }
                            switch (alt24)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1079:22: ( LT | GT | LTE | GTE | INSTANCEOF | IN ) shiftExpression
                                    {
                                        DebugLocation(1079, 22);
                                        if ((input.LA(1) >= GT && input.LA(1) <= GTE) || input.LA(1) == IN || input.LA(1) == INSTANCEOF || (input.LA(1) >= LT && input.LA(1) <= LTE))
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1079, 64);
                                        PushFollow(Follow._shiftExpression_in_relationalExpression3723);
                                        shiftExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop24;
                            }
                        }

                    loop24:
                        ;

                    }
                    finally { DebugExitSubRule(24); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("relationalExpression", 26);
                LeaveRule("relationalExpression", 26);
                LeaveRule_relationalExpression();
            }
            DebugLocation(1080, 1);
        }
        finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
        return retval;

    }
    // $ANTLR end "relationalExpression"

    partial void EnterRule_relationalExpressionNoIn();
    partial void LeaveRule_relationalExpressionNoIn();
    // $ANTLR start "relationalExpressionNoIn"
    // ES3YUITest.g:1082:1: relationalExpressionNoIn : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) shiftExpression )* ;
    [GrammarRule("relationalExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> relationalExpressionNoIn()
    {
        EnterRule_relationalExpressionNoIn();
        EnterRule("relationalExpressionNoIn", 27);
        TraceIn("relationalExpressionNoIn", 27);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
            DebugLocation(1082, 1);
            try
            {
                // ES3YUITest.g:1083:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) shiftExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1083:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) shiftExpression )*
                {
                    DebugLocation(1083, 4);
                    PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn3737);
                    shiftExpression();
                    PopFollow();

                    DebugLocation(1083, 20);
                    // ES3YUITest.g:1083:20: ( ( LT | GT | LTE | GTE | INSTANCEOF ) shiftExpression )*
                    try
                    {
                        DebugEnterSubRule(25);
                        while (true)
                        {
                            int alt25 = 2;
                            try
                            {
                                DebugEnterDecision(25, false);
                                int LA25_1 = input.LA(1);

                                if (((LA25_1 >= GT && LA25_1 <= GTE) || LA25_1 == INSTANCEOF || (LA25_1 >= LT && LA25_1 <= LTE)))
                                {
                                    alt25 = 1;
                                }


                            }
                            finally { DebugExitDecision(25); }
                            switch (alt25)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1083:22: ( LT | GT | LTE | GTE | INSTANCEOF ) shiftExpression
                                    {
                                        DebugLocation(1083, 22);
                                        if ((input.LA(1) >= GT && input.LA(1) <= GTE) || input.LA(1) == INSTANCEOF || (input.LA(1) >= LT && input.LA(1) <= LTE))
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1083, 59);
                                        PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn3763);
                                        shiftExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop25;
                            }
                        }

                    loop25:
                        ;

                    }
                    finally { DebugExitSubRule(25); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("relationalExpressionNoIn", 27);
                LeaveRule("relationalExpressionNoIn", 27);
                LeaveRule_relationalExpressionNoIn();
            }
            DebugLocation(1084, 1);
        }
        finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "relationalExpressionNoIn"

    partial void EnterRule_equalityExpression();
    partial void LeaveRule_equalityExpression();
    // $ANTLR start "equalityExpression"
    // ES3YUITest.g:1090:1: equalityExpression : relationalExpression ( ( EQ | NEQ | SAME | NSAME ) relationalExpression )* ;
    [GrammarRule("equalityExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> equalityExpression()
    {
        EnterRule_equalityExpression();
        EnterRule("equalityExpression", 28);
        TraceIn("equalityExpression", 28);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "equalityExpression");
            DebugLocation(1090, 1);
            try
            {
                // ES3YUITest.g:1091:2: ( relationalExpression ( ( EQ | NEQ | SAME | NSAME ) relationalExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1091:4: relationalExpression ( ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
                {
                    DebugLocation(1091, 4);
                    PushFollow(Follow._relationalExpression_in_equalityExpression3782);
                    relationalExpression();
                    PopFollow();

                    DebugLocation(1091, 25);
                    // ES3YUITest.g:1091:25: ( ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
                    try
                    {
                        DebugEnterSubRule(26);
                        while (true)
                        {
                            int alt26 = 2;
                            try
                            {
                                DebugEnterDecision(26, false);
                                int LA26_1 = input.LA(1);

                                if ((LA26_1 == EQ || LA26_1 == NEQ || LA26_1 == NSAME || LA26_1 == SAME))
                                {
                                    alt26 = 1;
                                }


                            }
                            finally { DebugExitDecision(26); }
                            switch (alt26)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1091:27: ( EQ | NEQ | SAME | NSAME ) relationalExpression
                                    {
                                        DebugLocation(1091, 27);
                                        if (input.LA(1) == EQ || input.LA(1) == NEQ || input.LA(1) == NSAME || input.LA(1) == SAME)
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1091, 55);
                                        PushFollow(Follow._relationalExpression_in_equalityExpression3804);
                                        relationalExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop26;
                            }
                        }

                    loop26:
                        ;

                    }
                    finally { DebugExitSubRule(26); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("equalityExpression", 28);
                LeaveRule("equalityExpression", 28);
                LeaveRule_equalityExpression();
            }
            DebugLocation(1092, 1);
        }
        finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
        return retval;

    }
    // $ANTLR end "equalityExpression"

    partial void EnterRule_equalityExpressionNoIn();
    partial void LeaveRule_equalityExpressionNoIn();
    // $ANTLR start "equalityExpressionNoIn"
    // ES3YUITest.g:1094:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* ;
    [GrammarRule("equalityExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> equalityExpressionNoIn()
    {
        EnterRule_equalityExpressionNoIn();
        EnterRule("equalityExpressionNoIn", 29);
        TraceIn("equalityExpressionNoIn", 29);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
            DebugLocation(1094, 1);
            try
            {
                // ES3YUITest.g:1095:2: ( relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1095:4: relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
                {
                    DebugLocation(1095, 4);
                    PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn3818);
                    relationalExpressionNoIn();
                    PopFollow();

                    DebugLocation(1095, 29);
                    // ES3YUITest.g:1095:29: ( ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(27);
                        while (true)
                        {
                            int alt27 = 2;
                            try
                            {
                                DebugEnterDecision(27, false);
                                int LA27_1 = input.LA(1);

                                if ((LA27_1 == EQ || LA27_1 == NEQ || LA27_1 == NSAME || LA27_1 == SAME))
                                {
                                    alt27 = 1;
                                }


                            }
                            finally { DebugExitDecision(27); }
                            switch (alt27)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1095:31: ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn
                                    {
                                        DebugLocation(1095, 31);
                                        if (input.LA(1) == EQ || input.LA(1) == NEQ || input.LA(1) == NSAME || input.LA(1) == SAME)
                                        {
                                            input.Consume();
                                            state.errorRecovery = false;
                                        }
                                        else
                                        {
                                            MismatchedSetException mse = new MismatchedSetException(null, input);
                                            DebugRecognitionException(mse);
                                            throw mse;
                                        }

                                        DebugLocation(1095, 59);
                                        PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn3840);
                                        relationalExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop27;
                            }
                        }

                    loop27:
                        ;

                    }
                    finally { DebugExitSubRule(27); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("equalityExpressionNoIn", 29);
                LeaveRule("equalityExpressionNoIn", 29);
                LeaveRule_equalityExpressionNoIn();
            }
            DebugLocation(1096, 1);
        }
        finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "equalityExpressionNoIn"

    partial void EnterRule_bitwiseANDExpression();
    partial void LeaveRule_bitwiseANDExpression();
    // $ANTLR start "bitwiseANDExpression"
    // ES3YUITest.g:1102:1: bitwiseANDExpression : equalityExpression ( AND equalityExpression )* ;
    [GrammarRule("bitwiseANDExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseANDExpression()
    {
        EnterRule_bitwiseANDExpression();
        EnterRule("bitwiseANDExpression", 30);
        TraceIn("bitwiseANDExpression", 30);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
            DebugLocation(1102, 1);
            try
            {
                // ES3YUITest.g:1103:2: ( equalityExpression ( AND equalityExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1103:4: equalityExpression ( AND equalityExpression )*
                {
                    DebugLocation(1103, 4);
                    PushFollow(Follow._equalityExpression_in_bitwiseANDExpression3860);
                    equalityExpression();
                    PopFollow();

                    DebugLocation(1103, 23);
                    // ES3YUITest.g:1103:23: ( AND equalityExpression )*
                    try
                    {
                        DebugEnterSubRule(28);
                        while (true)
                        {
                            int alt28 = 2;
                            try
                            {
                                DebugEnterDecision(28, false);
                                int LA28_1 = input.LA(1);

                                if ((LA28_1 == AND))
                                {
                                    alt28 = 1;
                                }


                            }
                            finally { DebugExitDecision(28); }
                            switch (alt28)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1103:25: AND equalityExpression
                                    {
                                        DebugLocation(1103, 25);
                                        Match(input, AND, Follow._AND_in_bitwiseANDExpression3864);
                                        DebugLocation(1103, 29);
                                        PushFollow(Follow._equalityExpression_in_bitwiseANDExpression3866);
                                        equalityExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop28;
                            }
                        }

                    loop28:
                        ;

                    }
                    finally { DebugExitSubRule(28); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseANDExpression", 30);
                LeaveRule("bitwiseANDExpression", 30);
                LeaveRule_bitwiseANDExpression();
            }
            DebugLocation(1104, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
        return retval;

    }
    // $ANTLR end "bitwiseANDExpression"

    partial void EnterRule_bitwiseANDExpressionNoIn();
    partial void LeaveRule_bitwiseANDExpressionNoIn();
    // $ANTLR start "bitwiseANDExpressionNoIn"
    // ES3YUITest.g:1106:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( AND equalityExpressionNoIn )* ;
    [GrammarRule("bitwiseANDExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseANDExpressionNoIn()
    {
        EnterRule_bitwiseANDExpressionNoIn();
        EnterRule("bitwiseANDExpressionNoIn", 31);
        TraceIn("bitwiseANDExpressionNoIn", 31);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
            DebugLocation(1106, 1);
            try
            {
                // ES3YUITest.g:1107:2: ( equalityExpressionNoIn ( AND equalityExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1107:4: equalityExpressionNoIn ( AND equalityExpressionNoIn )*
                {
                    DebugLocation(1107, 4);
                    PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3880);
                    equalityExpressionNoIn();
                    PopFollow();

                    DebugLocation(1107, 27);
                    // ES3YUITest.g:1107:27: ( AND equalityExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(29);
                        while (true)
                        {
                            int alt29 = 2;
                            try
                            {
                                DebugEnterDecision(29, false);
                                int LA29_1 = input.LA(1);

                                if ((LA29_1 == AND))
                                {
                                    alt29 = 1;
                                }


                            }
                            finally { DebugExitDecision(29); }
                            switch (alt29)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1107:29: AND equalityExpressionNoIn
                                    {
                                        DebugLocation(1107, 29);
                                        Match(input, AND, Follow._AND_in_bitwiseANDExpressionNoIn3884);
                                        DebugLocation(1107, 33);
                                        PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3886);
                                        equalityExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop29;
                            }
                        }

                    loop29:
                        ;

                    }
                    finally { DebugExitSubRule(29); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseANDExpressionNoIn", 31);
                LeaveRule("bitwiseANDExpressionNoIn", 31);
                LeaveRule_bitwiseANDExpressionNoIn();
            }
            DebugLocation(1108, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "bitwiseANDExpressionNoIn"

    partial void EnterRule_bitwiseXORExpression();
    partial void LeaveRule_bitwiseXORExpression();
    // $ANTLR start "bitwiseXORExpression"
    // ES3YUITest.g:1110:1: bitwiseXORExpression : bitwiseANDExpression ( XOR bitwiseANDExpression )* ;
    [GrammarRule("bitwiseXORExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseXORExpression()
    {
        EnterRule_bitwiseXORExpression();
        EnterRule("bitwiseXORExpression", 32);
        TraceIn("bitwiseXORExpression", 32);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
            DebugLocation(1110, 1);
            try
            {
                // ES3YUITest.g:1111:2: ( bitwiseANDExpression ( XOR bitwiseANDExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1111:4: bitwiseANDExpression ( XOR bitwiseANDExpression )*
                {
                    DebugLocation(1111, 4);
                    PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3902);
                    bitwiseANDExpression();
                    PopFollow();

                    DebugLocation(1111, 25);
                    // ES3YUITest.g:1111:25: ( XOR bitwiseANDExpression )*
                    try
                    {
                        DebugEnterSubRule(30);
                        while (true)
                        {
                            int alt30 = 2;
                            try
                            {
                                DebugEnterDecision(30, false);
                                int LA30_1 = input.LA(1);

                                if ((LA30_1 == XOR))
                                {
                                    alt30 = 1;
                                }


                            }
                            finally { DebugExitDecision(30); }
                            switch (alt30)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1111:27: XOR bitwiseANDExpression
                                    {
                                        DebugLocation(1111, 27);
                                        Match(input, XOR, Follow._XOR_in_bitwiseXORExpression3906);
                                        DebugLocation(1111, 31);
                                        PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3908);
                                        bitwiseANDExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop30;
                            }
                        }

                    loop30:
                        ;

                    }
                    finally { DebugExitSubRule(30); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseXORExpression", 32);
                LeaveRule("bitwiseXORExpression", 32);
                LeaveRule_bitwiseXORExpression();
            }
            DebugLocation(1112, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
        return retval;

    }
    // $ANTLR end "bitwiseXORExpression"

    partial void EnterRule_bitwiseXORExpressionNoIn();
    partial void LeaveRule_bitwiseXORExpressionNoIn();
    // $ANTLR start "bitwiseXORExpressionNoIn"
    // ES3YUITest.g:1114:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( XOR bitwiseANDExpressionNoIn )* ;
    [GrammarRule("bitwiseXORExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseXORExpressionNoIn()
    {
        EnterRule_bitwiseXORExpressionNoIn();
        EnterRule("bitwiseXORExpressionNoIn", 33);
        TraceIn("bitwiseXORExpressionNoIn", 33);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
            DebugLocation(1114, 1);
            try
            {
                // ES3YUITest.g:1115:2: ( bitwiseANDExpressionNoIn ( XOR bitwiseANDExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1115:4: bitwiseANDExpressionNoIn ( XOR bitwiseANDExpressionNoIn )*
                {
                    DebugLocation(1115, 4);
                    PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn3924);
                    bitwiseANDExpressionNoIn();
                    PopFollow();

                    DebugLocation(1115, 29);
                    // ES3YUITest.g:1115:29: ( XOR bitwiseANDExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(31);
                        while (true)
                        {
                            int alt31 = 2;
                            try
                            {
                                DebugEnterDecision(31, false);
                                int LA31_1 = input.LA(1);

                                if ((LA31_1 == XOR))
                                {
                                    alt31 = 1;
                                }


                            }
                            finally { DebugExitDecision(31); }
                            switch (alt31)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1115:31: XOR bitwiseANDExpressionNoIn
                                    {
                                        DebugLocation(1115, 31);
                                        Match(input, XOR, Follow._XOR_in_bitwiseXORExpressionNoIn3928);
                                        DebugLocation(1115, 35);
                                        PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn3930);
                                        bitwiseANDExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop31;
                            }
                        }

                    loop31:
                        ;

                    }
                    finally { DebugExitSubRule(31); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseXORExpressionNoIn", 33);
                LeaveRule("bitwiseXORExpressionNoIn", 33);
                LeaveRule_bitwiseXORExpressionNoIn();
            }
            DebugLocation(1116, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "bitwiseXORExpressionNoIn"

    partial void EnterRule_bitwiseORExpression();
    partial void LeaveRule_bitwiseORExpression();
    // $ANTLR start "bitwiseORExpression"
    // ES3YUITest.g:1118:1: bitwiseORExpression : bitwiseXORExpression ( OR bitwiseXORExpression )* ;
    [GrammarRule("bitwiseORExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseORExpression()
    {
        EnterRule_bitwiseORExpression();
        EnterRule("bitwiseORExpression", 34);
        TraceIn("bitwiseORExpression", 34);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseORExpression");
            DebugLocation(1118, 1);
            try
            {
                // ES3YUITest.g:1119:2: ( bitwiseXORExpression ( OR bitwiseXORExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1119:4: bitwiseXORExpression ( OR bitwiseXORExpression )*
                {
                    DebugLocation(1119, 4);
                    PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression3945);
                    bitwiseXORExpression();
                    PopFollow();

                    DebugLocation(1119, 25);
                    // ES3YUITest.g:1119:25: ( OR bitwiseXORExpression )*
                    try
                    {
                        DebugEnterSubRule(32);
                        while (true)
                        {
                            int alt32 = 2;
                            try
                            {
                                DebugEnterDecision(32, false);
                                int LA32_1 = input.LA(1);

                                if ((LA32_1 == OR))
                                {
                                    alt32 = 1;
                                }


                            }
                            finally { DebugExitDecision(32); }
                            switch (alt32)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1119:27: OR bitwiseXORExpression
                                    {
                                        DebugLocation(1119, 27);
                                        Match(input, OR, Follow._OR_in_bitwiseORExpression3949);
                                        DebugLocation(1119, 30);
                                        PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression3951);
                                        bitwiseXORExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop32;
                            }
                        }

                    loop32:
                        ;

                    }
                    finally { DebugExitSubRule(32); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseORExpression", 34);
                LeaveRule("bitwiseORExpression", 34);
                LeaveRule_bitwiseORExpression();
            }
            DebugLocation(1120, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
        return retval;

    }
    // $ANTLR end "bitwiseORExpression"

    partial void EnterRule_bitwiseORExpressionNoIn();
    partial void LeaveRule_bitwiseORExpressionNoIn();
    // $ANTLR start "bitwiseORExpressionNoIn"
    // ES3YUITest.g:1122:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( OR bitwiseXORExpressionNoIn )* ;
    [GrammarRule("bitwiseORExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> bitwiseORExpressionNoIn()
    {
        EnterRule_bitwiseORExpressionNoIn();
        EnterRule("bitwiseORExpressionNoIn", 35);
        TraceIn("bitwiseORExpressionNoIn", 35);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
            DebugLocation(1122, 1);
            try
            {
                // ES3YUITest.g:1123:2: ( bitwiseXORExpressionNoIn ( OR bitwiseXORExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1123:4: bitwiseXORExpressionNoIn ( OR bitwiseXORExpressionNoIn )*
                {
                    DebugLocation(1123, 4);
                    PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3966);
                    bitwiseXORExpressionNoIn();
                    PopFollow();

                    DebugLocation(1123, 29);
                    // ES3YUITest.g:1123:29: ( OR bitwiseXORExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(33);
                        while (true)
                        {
                            int alt33 = 2;
                            try
                            {
                                DebugEnterDecision(33, false);
                                int LA33_1 = input.LA(1);

                                if ((LA33_1 == OR))
                                {
                                    alt33 = 1;
                                }


                            }
                            finally { DebugExitDecision(33); }
                            switch (alt33)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1123:31: OR bitwiseXORExpressionNoIn
                                    {
                                        DebugLocation(1123, 31);
                                        Match(input, OR, Follow._OR_in_bitwiseORExpressionNoIn3970);
                                        DebugLocation(1123, 34);
                                        PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3972);
                                        bitwiseXORExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop33;
                            }
                        }

                    loop33:
                        ;

                    }
                    finally { DebugExitSubRule(33); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("bitwiseORExpressionNoIn", 35);
                LeaveRule("bitwiseORExpressionNoIn", 35);
                LeaveRule_bitwiseORExpressionNoIn();
            }
            DebugLocation(1124, 1);
        }
        finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "bitwiseORExpressionNoIn"

    partial void EnterRule_logicalANDExpression();
    partial void LeaveRule_logicalANDExpression();
    // $ANTLR start "logicalANDExpression"
    // ES3YUITest.g:1130:1: logicalANDExpression : bitwiseORExpression ( LAND bitwiseORExpression )* ;
    [GrammarRule("logicalANDExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> logicalANDExpression()
    {
        EnterRule_logicalANDExpression();
        EnterRule("logicalANDExpression", 36);
        TraceIn("logicalANDExpression", 36);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "logicalANDExpression");
            DebugLocation(1130, 1);
            try
            {
                // ES3YUITest.g:1131:2: ( bitwiseORExpression ( LAND bitwiseORExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1131:4: bitwiseORExpression ( LAND bitwiseORExpression )*
                {
                    DebugLocation(1131, 4);
                    PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression3991);
                    bitwiseORExpression();
                    PopFollow();

                    DebugLocation(1131, 24);
                    // ES3YUITest.g:1131:24: ( LAND bitwiseORExpression )*
                    try
                    {
                        DebugEnterSubRule(34);
                        while (true)
                        {
                            int alt34 = 2;
                            try
                            {
                                DebugEnterDecision(34, false);
                                int LA34_1 = input.LA(1);

                                if ((LA34_1 == LAND))
                                {
                                    alt34 = 1;
                                }


                            }
                            finally { DebugExitDecision(34); }
                            switch (alt34)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1131:26: LAND bitwiseORExpression
                                    {
                                        DebugLocation(1131, 26);
                                        Match(input, LAND, Follow._LAND_in_logicalANDExpression3995);
                                        DebugLocation(1131, 31);
                                        PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression3997);
                                        bitwiseORExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop34;
                            }
                        }

                    loop34:
                        ;

                    }
                    finally { DebugExitSubRule(34); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("logicalANDExpression", 36);
                LeaveRule("logicalANDExpression", 36);
                LeaveRule_logicalANDExpression();
            }
            DebugLocation(1132, 1);
        }
        finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
        return retval;

    }
    // $ANTLR end "logicalANDExpression"

    partial void EnterRule_logicalANDExpressionNoIn();
    partial void LeaveRule_logicalANDExpressionNoIn();
    // $ANTLR start "logicalANDExpressionNoIn"
    // ES3YUITest.g:1134:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( LAND bitwiseORExpressionNoIn )* ;
    [GrammarRule("logicalANDExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> logicalANDExpressionNoIn()
    {
        EnterRule_logicalANDExpressionNoIn();
        EnterRule("logicalANDExpressionNoIn", 37);
        TraceIn("logicalANDExpressionNoIn", 37);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
            DebugLocation(1134, 1);
            try
            {
                // ES3YUITest.g:1135:2: ( bitwiseORExpressionNoIn ( LAND bitwiseORExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1135:4: bitwiseORExpressionNoIn ( LAND bitwiseORExpressionNoIn )*
                {
                    DebugLocation(1135, 4);
                    PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4011);
                    bitwiseORExpressionNoIn();
                    PopFollow();

                    DebugLocation(1135, 28);
                    // ES3YUITest.g:1135:28: ( LAND bitwiseORExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(35);
                        while (true)
                        {
                            int alt35 = 2;
                            try
                            {
                                DebugEnterDecision(35, false);
                                int LA35_1 = input.LA(1);

                                if ((LA35_1 == LAND))
                                {
                                    alt35 = 1;
                                }


                            }
                            finally { DebugExitDecision(35); }
                            switch (alt35)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1135:30: LAND bitwiseORExpressionNoIn
                                    {
                                        DebugLocation(1135, 30);
                                        Match(input, LAND, Follow._LAND_in_logicalANDExpressionNoIn4015);
                                        DebugLocation(1135, 35);
                                        PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4017);
                                        bitwiseORExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop35;
                            }
                        }

                    loop35:
                        ;

                    }
                    finally { DebugExitSubRule(35); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("logicalANDExpressionNoIn", 37);
                LeaveRule("logicalANDExpressionNoIn", 37);
                LeaveRule_logicalANDExpressionNoIn();
            }
            DebugLocation(1136, 1);
        }
        finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "logicalANDExpressionNoIn"

    partial void EnterRule_logicalORExpression();
    partial void LeaveRule_logicalORExpression();
    // $ANTLR start "logicalORExpression"
    // ES3YUITest.g:1138:1: logicalORExpression : logicalANDExpression ( LOR logicalANDExpression )* ;
    [GrammarRule("logicalORExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> logicalORExpression()
    {
        EnterRule_logicalORExpression();
        EnterRule("logicalORExpression", 38);
        TraceIn("logicalORExpression", 38);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "logicalORExpression");
            DebugLocation(1138, 1);
            try
            {
                // ES3YUITest.g:1139:2: ( logicalANDExpression ( LOR logicalANDExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1139:4: logicalANDExpression ( LOR logicalANDExpression )*
                {
                    DebugLocation(1139, 4);
                    PushFollow(Follow._logicalANDExpression_in_logicalORExpression4032);
                    logicalANDExpression();
                    PopFollow();

                    DebugLocation(1139, 25);
                    // ES3YUITest.g:1139:25: ( LOR logicalANDExpression )*
                    try
                    {
                        DebugEnterSubRule(36);
                        while (true)
                        {
                            int alt36 = 2;
                            try
                            {
                                DebugEnterDecision(36, false);
                                int LA36_1 = input.LA(1);

                                if ((LA36_1 == LOR))
                                {
                                    alt36 = 1;
                                }


                            }
                            finally { DebugExitDecision(36); }
                            switch (alt36)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1139:27: LOR logicalANDExpression
                                    {
                                        DebugLocation(1139, 27);
                                        Match(input, LOR, Follow._LOR_in_logicalORExpression4036);
                                        DebugLocation(1139, 31);
                                        PushFollow(Follow._logicalANDExpression_in_logicalORExpression4038);
                                        logicalANDExpression();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop36;
                            }
                        }

                    loop36:
                        ;

                    }
                    finally { DebugExitSubRule(36); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("logicalORExpression", 38);
                LeaveRule("logicalORExpression", 38);
                LeaveRule_logicalORExpression();
            }
            DebugLocation(1140, 1);
        }
        finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
        return retval;

    }
    // $ANTLR end "logicalORExpression"

    partial void EnterRule_logicalORExpressionNoIn();
    partial void LeaveRule_logicalORExpressionNoIn();
    // $ANTLR start "logicalORExpressionNoIn"
    // ES3YUITest.g:1142:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( LOR logicalANDExpressionNoIn )* ;
    [GrammarRule("logicalORExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> logicalORExpressionNoIn()
    {
        EnterRule_logicalORExpressionNoIn();
        EnterRule("logicalORExpressionNoIn", 39);
        TraceIn("logicalORExpressionNoIn", 39);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
            DebugLocation(1142, 1);
            try
            {
                // ES3YUITest.g:1143:2: ( logicalANDExpressionNoIn ( LOR logicalANDExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1143:4: logicalANDExpressionNoIn ( LOR logicalANDExpressionNoIn )*
                {
                    DebugLocation(1143, 4);
                    PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn4053);
                    logicalANDExpressionNoIn();
                    PopFollow();

                    DebugLocation(1143, 29);
                    // ES3YUITest.g:1143:29: ( LOR logicalANDExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(37);
                        while (true)
                        {
                            int alt37 = 2;
                            try
                            {
                                DebugEnterDecision(37, false);
                                int LA37_1 = input.LA(1);

                                if ((LA37_1 == LOR))
                                {
                                    alt37 = 1;
                                }


                            }
                            finally { DebugExitDecision(37); }
                            switch (alt37)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1143:31: LOR logicalANDExpressionNoIn
                                    {
                                        DebugLocation(1143, 31);
                                        Match(input, LOR, Follow._LOR_in_logicalORExpressionNoIn4057);
                                        DebugLocation(1143, 35);
                                        PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn4059);
                                        logicalANDExpressionNoIn();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop37;
                            }
                        }

                    loop37:
                        ;

                    }
                    finally { DebugExitSubRule(37); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("logicalORExpressionNoIn", 39);
                LeaveRule("logicalORExpressionNoIn", 39);
                LeaveRule_logicalORExpressionNoIn();
            }
            DebugLocation(1144, 1);
        }
        finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "logicalORExpressionNoIn"

    partial void EnterRule_conditionalExpression();
    partial void LeaveRule_conditionalExpression();
    // $ANTLR start "conditionalExpression"
    // ES3YUITest.g:1150:1: conditionalExpression : logicalORExpression ( QUE assignmentExpression COLON assignmentExpression )? ;
    [GrammarRule("conditionalExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> conditionalExpression()
    {
        EnterRule_conditionalExpression();
        EnterRule("conditionalExpression", 40);
        TraceIn("conditionalExpression", 40);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "conditionalExpression");
            DebugLocation(1150, 1);
            try
            {
                // ES3YUITest.g:1151:2: ( logicalORExpression ( QUE assignmentExpression COLON assignmentExpression )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1151:4: logicalORExpression ( QUE assignmentExpression COLON assignmentExpression )?
                {
                    DebugLocation(1151, 4);
                    PushFollow(Follow._logicalORExpression_in_conditionalExpression4078);
                    logicalORExpression();
                    PopFollow();

                    DebugLocation(1151, 24);
                    // ES3YUITest.g:1151:24: ( QUE assignmentExpression COLON assignmentExpression )?
                    int alt38 = 2;
                    try
                    {
                        DebugEnterSubRule(38);
                        try
                        {
                            DebugEnterDecision(38, false);
                            int LA38_1 = input.LA(1);

                            if ((LA38_1 == QUE))
                            {
                                alt38 = 1;
                            }
                        }
                        finally { DebugExitDecision(38); }
                        switch (alt38)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1151:26: QUE assignmentExpression COLON assignmentExpression
                                {
                                    DebugLocation(1151, 26);
                                    Match(input, QUE, Follow._QUE_in_conditionalExpression4082);
                                    DebugLocation(1151, 30);
                                    PushFollow(Follow._assignmentExpression_in_conditionalExpression4084);
                                    assignmentExpression();
                                    PopFollow();

                                    DebugLocation(1151, 51);
                                    Match(input, COLON, Follow._COLON_in_conditionalExpression4086);
                                    DebugLocation(1151, 57);
                                    PushFollow(Follow._assignmentExpression_in_conditionalExpression4088);
                                    assignmentExpression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(38); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("conditionalExpression", 40);
                LeaveRule("conditionalExpression", 40);
                LeaveRule_conditionalExpression();
            }
            DebugLocation(1152, 1);
        }
        finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
        return retval;

    }
    // $ANTLR end "conditionalExpression"

    partial void EnterRule_conditionalExpressionNoIn();
    partial void LeaveRule_conditionalExpressionNoIn();
    // $ANTLR start "conditionalExpressionNoIn"
    // ES3YUITest.g:1154:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( QUE assignmentExpressionNoIn COLON assignmentExpressionNoIn )? ;
    [GrammarRule("conditionalExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> conditionalExpressionNoIn()
    {
        EnterRule_conditionalExpressionNoIn();
        EnterRule("conditionalExpressionNoIn", 41);
        TraceIn("conditionalExpressionNoIn", 41);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
            DebugLocation(1154, 1);
            try
            {
                // ES3YUITest.g:1155:2: ( logicalORExpressionNoIn ( QUE assignmentExpressionNoIn COLON assignmentExpressionNoIn )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1155:4: logicalORExpressionNoIn ( QUE assignmentExpressionNoIn COLON assignmentExpressionNoIn )?
                {
                    DebugLocation(1155, 4);
                    PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn4102);
                    logicalORExpressionNoIn();
                    PopFollow();

                    DebugLocation(1155, 28);
                    // ES3YUITest.g:1155:28: ( QUE assignmentExpressionNoIn COLON assignmentExpressionNoIn )?
                    int alt39 = 2;
                    try
                    {
                        DebugEnterSubRule(39);
                        try
                        {
                            DebugEnterDecision(39, false);
                            int LA39_1 = input.LA(1);

                            if ((LA39_1 == QUE))
                            {
                                alt39 = 1;
                            }
                        }
                        finally { DebugExitDecision(39); }
                        switch (alt39)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1155:30: QUE assignmentExpressionNoIn COLON assignmentExpressionNoIn
                                {
                                    DebugLocation(1155, 30);
                                    Match(input, QUE, Follow._QUE_in_conditionalExpressionNoIn4106);
                                    DebugLocation(1155, 34);
                                    PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn4108);
                                    assignmentExpressionNoIn();
                                    PopFollow();

                                    DebugLocation(1155, 59);
                                    Match(input, COLON, Follow._COLON_in_conditionalExpressionNoIn4110);
                                    DebugLocation(1155, 65);
                                    PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn4112);
                                    assignmentExpressionNoIn();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(39); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("conditionalExpressionNoIn", 41);
                LeaveRule("conditionalExpressionNoIn", 41);
                LeaveRule_conditionalExpressionNoIn();
            }
            DebugLocation(1156, 1);
        }
        finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "conditionalExpressionNoIn"

    partial void EnterRule_assignmentExpression();
    partial void LeaveRule_assignmentExpression();
    // $ANTLR start "assignmentExpression"
    // ES3YUITest.g:1184:1: assignmentExpression : lhs= conditionalExpression ({...}? assignmentOperator assignmentExpression )? ;
    [GrammarRule("assignmentExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> assignmentExpression()
    {
        EnterRule_assignmentExpression();
        EnterRule("assignmentExpression", 42);
        TraceIn("assignmentExpression", 42);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> lhs = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);


        object[] isLhs = new object[1];

        try
        {
            DebugEnterRule(GrammarFileName, "assignmentExpression");
            DebugLocation(1184, 1);
            try
            {
                // ES3YUITest.g:1189:2: (lhs= conditionalExpression ({...}? assignmentOperator assignmentExpression )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1189:4: lhs= conditionalExpression ({...}? assignmentOperator assignmentExpression )?
                {
                    DebugLocation(1189, 7);
                    PushFollow(Follow._conditionalExpression_in_assignmentExpression4140);
                    lhs = conditionalExpression();
                    PopFollow();

                    DebugLocation(1190, 2);
                    // ES3YUITest.g:1190:2: ({...}? assignmentOperator assignmentExpression )?
                    int alt40 = 2;
                    try
                    {
                        DebugEnterSubRule(40);
                        try
                        {
                            DebugEnterDecision(40, false);
                            int LA40_1 = input.LA(1);

                            if ((LA40_1 == ADDASS || LA40_1 == ANDASS || LA40_1 == ASSIGN || LA40_1 == DIVASS || LA40_1 == MODASS || LA40_1 == MULASS || LA40_1 == ORASS || LA40_1 == SHLASS || LA40_1 == SHRASS || LA40_1 == SHUASS || LA40_1 == SUBASS || LA40_1 == XORASS))
                            {
                                int LA40_2 = input.LA(2);

                                if (((IsLeftHandSideAssign(lhs, isLhs))))
                                {
                                    alt40 = 1;
                                }
                            }
                        }
                        finally { DebugExitDecision(40); }
                        switch (alt40)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1190:4: {...}? assignmentOperator assignmentExpression
                                {
                                    DebugLocation(1190, 4);
                                    if (!((IsLeftHandSideAssign(lhs, isLhs))))
                                    {
                                        throw new FailedPredicateException(input, "assignmentExpression", " IsLeftHandSideAssign(lhs, isLhs) ");
                                    }
                                    DebugLocation(1190, 42);
                                    PushFollow(Follow._assignmentOperator_in_assignmentExpression4147);
                                    assignmentOperator();
                                    PopFollow();

                                    DebugLocation(1190, 61);
                                    PushFollow(Follow._assignmentExpression_in_assignmentExpression4149);
                                    assignmentExpression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(40); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("assignmentExpression", 42);
                LeaveRule("assignmentExpression", 42);
                LeaveRule_assignmentExpression();
            }
            DebugLocation(1191, 1);
        }
        finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
        return retval;

    }
    // $ANTLR end "assignmentExpression"

    partial void EnterRule_assignmentOperator();
    partial void LeaveRule_assignmentOperator();
    // $ANTLR start "assignmentOperator"
    // ES3YUITest.g:1193:1: assignmentOperator : ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS );
    [GrammarRule("assignmentOperator")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> assignmentOperator()
    {
        EnterRule_assignmentOperator();
        EnterRule("assignmentOperator", 43);
        TraceIn("assignmentOperator", 43);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "assignmentOperator");
            DebugLocation(1193, 1);
            try
            {
                // ES3YUITest.g:1194:2: ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS )
                DebugEnterAlt(1);
                // ES3YUITest.g:
                {
                    DebugLocation(1194, 2);
                    if (input.LA(1) == ADDASS || input.LA(1) == ANDASS || input.LA(1) == ASSIGN || input.LA(1) == DIVASS || input.LA(1) == MODASS || input.LA(1) == MULASS || input.LA(1) == ORASS || input.LA(1) == SHLASS || input.LA(1) == SHRASS || input.LA(1) == SHUASS || input.LA(1) == SUBASS || input.LA(1) == XORASS)
                    {
                        input.Consume();
                        state.errorRecovery = false;
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        throw mse;
                    }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("assignmentOperator", 43);
                LeaveRule("assignmentOperator", 43);
                LeaveRule_assignmentOperator();
            }
            DebugLocation(1195, 1);
        }
        finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
        return retval;

    }
    // $ANTLR end "assignmentOperator"

    partial void EnterRule_assignmentExpressionNoIn();
    partial void LeaveRule_assignmentExpressionNoIn();
    // $ANTLR start "assignmentExpressionNoIn"
    // ES3YUITest.g:1197:1: assignmentExpressionNoIn : lhs= conditionalExpressionNoIn ({...}? assignmentOperator assignmentExpressionNoIn )? ;
    [GrammarRule("assignmentExpressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> assignmentExpressionNoIn()
    {
        EnterRule_assignmentExpressionNoIn();
        EnterRule("assignmentExpressionNoIn", 44);
        TraceIn("assignmentExpressionNoIn", 44);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> lhs = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);


        object[] isLhs = new object[1];

        try
        {
            DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
            DebugLocation(1197, 1);
            try
            {
                // ES3YUITest.g:1202:2: (lhs= conditionalExpressionNoIn ({...}? assignmentOperator assignmentExpressionNoIn )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1202:4: lhs= conditionalExpressionNoIn ({...}? assignmentOperator assignmentExpressionNoIn )?
                {
                    DebugLocation(1202, 7);
                    PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn4226);
                    lhs = conditionalExpressionNoIn();
                    PopFollow();

                    DebugLocation(1203, 2);
                    // ES3YUITest.g:1203:2: ({...}? assignmentOperator assignmentExpressionNoIn )?
                    int alt41 = 2;
                    try
                    {
                        DebugEnterSubRule(41);
                        try
                        {
                            DebugEnterDecision(41, false);
                            int LA41_1 = input.LA(1);

                            if ((LA41_1 == ADDASS || LA41_1 == ANDASS || LA41_1 == ASSIGN || LA41_1 == DIVASS || LA41_1 == MODASS || LA41_1 == MULASS || LA41_1 == ORASS || LA41_1 == SHLASS || LA41_1 == SHRASS || LA41_1 == SHUASS || LA41_1 == SUBASS || LA41_1 == XORASS))
                            {
                                int LA41_2 = input.LA(2);

                                if (((IsLeftHandSideAssign(lhs, isLhs))))
                                {
                                    alt41 = 1;
                                }
                            }
                        }
                        finally { DebugExitDecision(41); }
                        switch (alt41)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1203:4: {...}? assignmentOperator assignmentExpressionNoIn
                                {
                                    DebugLocation(1203, 4);
                                    if (!((IsLeftHandSideAssign(lhs, isLhs))))
                                    {
                                        throw new FailedPredicateException(input, "assignmentExpressionNoIn", " IsLeftHandSideAssign(lhs, isLhs) ");
                                    }
                                    DebugLocation(1203, 42);
                                    PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn4233);
                                    assignmentOperator();
                                    PopFollow();

                                    DebugLocation(1203, 61);
                                    PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn4235);
                                    assignmentExpressionNoIn();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(41); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("assignmentExpressionNoIn", 44);
                LeaveRule("assignmentExpressionNoIn", 44);
                LeaveRule_assignmentExpressionNoIn();
            }
            DebugLocation(1204, 1);
        }
        finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
        return retval;

    }
    // $ANTLR end "assignmentExpressionNoIn"

    partial void EnterRule_expression();
    partial void LeaveRule_expression();
    // $ANTLR start "expression"
    // ES3YUITest.g:1210:1: expression :exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* ;
    [GrammarRule("expression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> expression()
    {
        EnterRule_expression();
        EnterRule("expression", 45);
        TraceIn("expression", 45);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        List<StringTemplate> list_exprs = null;
        TemplateParserRuleReturnScope<StringTemplate, IToken> exprs = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        try
        {
            DebugEnterRule(GrammarFileName, "expression");
            DebugLocation(1210, 1);
            try
            {
                // ES3YUITest.g:1211:2: (exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1211:4: exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )*
                {
                    DebugLocation(1211, 9);
                    PushFollow(Follow._assignmentExpression_in_expression4257);
                    exprs = assignmentExpression();
                    PopFollow();

                    if (list_exprs == null) list_exprs = new List<StringTemplate>();
                    list_exprs.Add(exprs.Template);

                    DebugLocation(1211, 32);
                    // ES3YUITest.g:1211:32: ( COMMA exprs+= assignmentExpression )*
                    try
                    {
                        DebugEnterSubRule(42);
                        while (true)
                        {
                            int alt42 = 2;
                            try
                            {
                                DebugEnterDecision(42, false);
                                int LA42_1 = input.LA(1);

                                if ((LA42_1 == COMMA))
                                {
                                    alt42 = 1;
                                }


                            }
                            finally { DebugExitDecision(42); }
                            switch (alt42)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1211:34: COMMA exprs+= assignmentExpression
                                    {
                                        DebugLocation(1211, 34);
                                        Match(input, COMMA, Follow._COMMA_in_expression4261);
                                        DebugLocation(1211, 45);
                                        PushFollow(Follow._assignmentExpression_in_expression4265);
                                        exprs = assignmentExpression();
                                        PopFollow();

                                        if (list_exprs == null) list_exprs = new List<StringTemplate>();
                                        list_exprs.Add(exprs.Template);


                                    }
                                    break;

                                default:
                                    goto loop42;
                            }
                        }

                    loop42:
                        ;

                    }
                    finally { DebugExitSubRule(42); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("expression", 45);
                LeaveRule("expression", 45);
                LeaveRule_expression();
            }
            DebugLocation(1214, 1);
        }
        finally { DebugExitRule(GrammarFileName, "expression"); }
        return retval;

    }
    // $ANTLR end "expression"

    partial void EnterRule_expressionNoIn();
    partial void LeaveRule_expressionNoIn();
    // $ANTLR start "expressionNoIn"
    // ES3YUITest.g:1216:1: expressionNoIn :exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* ;
    [GrammarRule("expressionNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> expressionNoIn()
    {
        EnterRule_expressionNoIn();
        EnterRule("expressionNoIn", 46);
        TraceIn("expressionNoIn", 46);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        List<StringTemplate> list_exprs = null;
        TemplateParserRuleReturnScope<StringTemplate, IToken> exprs = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        try
        {
            DebugEnterRule(GrammarFileName, "expressionNoIn");
            DebugLocation(1216, 1);
            try
            {
                // ES3YUITest.g:1217:2: (exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1217:4: exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )*
                {
                    DebugLocation(1217, 9);
                    PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn4285);
                    exprs = assignmentExpressionNoIn();
                    PopFollow();

                    if (list_exprs == null) list_exprs = new List<StringTemplate>();
                    list_exprs.Add(exprs.Template);

                    DebugLocation(1217, 36);
                    // ES3YUITest.g:1217:36: ( COMMA exprs+= assignmentExpressionNoIn )*
                    try
                    {
                        DebugEnterSubRule(43);
                        while (true)
                        {
                            int alt43 = 2;
                            try
                            {
                                DebugEnterDecision(43, false);
                                int LA43_1 = input.LA(1);

                                if ((LA43_1 == COMMA))
                                {
                                    alt43 = 1;
                                }


                            }
                            finally { DebugExitDecision(43); }
                            switch (alt43)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1217:38: COMMA exprs+= assignmentExpressionNoIn
                                    {
                                        DebugLocation(1217, 38);
                                        Match(input, COMMA, Follow._COMMA_in_expressionNoIn4289);
                                        DebugLocation(1217, 49);
                                        PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn4293);
                                        exprs = assignmentExpressionNoIn();
                                        PopFollow();

                                        if (list_exprs == null) list_exprs = new List<StringTemplate>();
                                        list_exprs.Add(exprs.Template);


                                    }
                                    break;

                                default:
                                    goto loop43;
                            }
                        }

                    loop43:
                        ;

                    }
                    finally { DebugExitSubRule(43); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("expressionNoIn", 46);
                LeaveRule("expressionNoIn", 46);
                LeaveRule_expressionNoIn();
            }
            DebugLocation(1220, 1);
        }
        finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
        return retval;

    }
    // $ANTLR end "expressionNoIn"

    partial void EnterRule_semic();
    partial void LeaveRule_semic();
    // $ANTLR start "semic"
    // ES3YUITest.g:1244:1: semic : ( SEMIC | EOF | RBRACE | EOL | MultiLineComment );
    [GrammarRule("semic")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> semic()
    {
        EnterRule_semic();
        EnterRule("semic", 47);
        TraceIn("semic", 47);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);


        // Mark current position so we can unconsume a RBRACE.
        int marker = input.Mark();
        // Promote EOL if appropriate	
        PromoteEOL(retval);

        try
        {
            DebugEnterRule(GrammarFileName, "semic");
            DebugLocation(1244, 1);
            try
            {
                // ES3YUITest.g:1252:2: ( SEMIC | EOF | RBRACE | EOL | MultiLineComment )
                int alt44 = 5;
                try
                {
                    DebugEnterDecision(44, false);
                    switch (input.LA(1))
                    {
                        case SEMIC:
                            {
                                alt44 = 1;
                            }
                            break;
                        case EOF:
                            {
                                alt44 = 2;
                            }
                            break;
                        case RBRACE:
                            {
                                alt44 = 3;
                            }
                            break;
                        case EOL:
                            {
                                alt44 = 4;
                            }
                            break;
                        case MultiLineComment:
                            {
                                alt44 = 5;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(44); }
                switch (alt44)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1252:4: SEMIC
                        {
                            DebugLocation(1252, 4);
                            Match(input, SEMIC, Follow._SEMIC_in_semic4327);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1253:4: EOF
                        {
                            DebugLocation(1253, 4);
                            Match(input, EOF, Follow._EOF_in_semic4332);

                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:1254:4: RBRACE
                        {
                            DebugLocation(1254, 4);
                            Match(input, RBRACE, Follow._RBRACE_in_semic4337);
                            DebugLocation(1254, 11);
                            input.Rewind(marker);

                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:1255:4: EOL
                        {
                            DebugLocation(1255, 4);
                            Match(input, EOL, Follow._EOL_in_semic4344);

                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:1255:10: MultiLineComment
                        {
                            DebugLocation(1255, 10);
                            Match(input, MultiLineComment, Follow._MultiLineComment_in_semic4348);

                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("semic", 47);
                LeaveRule("semic", 47);
                LeaveRule_semic();
            }
            DebugLocation(1256, 1);
        }
        finally { DebugExitRule(GrammarFileName, "semic"); }
        return retval;

    }
    // $ANTLR end "semic"

    protected sealed partial class statement_scope
    {
        public bool isBlock;

        public statement_scope(ES3YUITestParser grammar) { OnCreated(grammar); }
        partial void OnCreated(ES3YUITestParser grammar);
    }
    partial void statement_scopeInit(statement_scope scope);
    partial void statement_scopeAfter(statement_scope scope);
    protected readonly ListStack<statement_scope> statement_stack = new ListStack<statement_scope>();

    partial void EnterRule_statement();
    partial void LeaveRule_statement();
    // $ANTLR start "statement"
    // ES3YUITest.g:1263:1: statement options {k=1; } : ({...}? block | statementTail ) -> {instrument && !$statement::isBlock}? cover_line(src=$program::namecode=$textline=$start.Line) -> ignore(code=$text);
    [GrammarRule("statement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> statement()
    {
        EnterRule_statement();
        EnterRule("statement", 48);
        TraceIn("statement", 48);
        statement_stack.Push(new statement_scope(this)); statement_scopeInit(statement_stack.Peek());
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);


        bool instrument = false;

        if (retval.Start.Line > program_stack.Peek().stopLine)
        {
            program_stack.Peek().stopLine = retval.Start.Line;
            instrument = true;
        }

        try
        {
            DebugEnterRule(GrammarFileName, "statement");
            DebugLocation(1263, 1);
            try
            {
                // ES3YUITest.g:1287:2: ( ({...}? block | statementTail ) -> {instrument && !$statement::isBlock}? cover_line(src=$program::namecode=$textline=$start.Line) -> ignore(code=$text))
                DebugEnterAlt(1);
                // ES3YUITest.g:1287:4: ({...}? block | statementTail )
                {
                    DebugLocation(1287, 4);
                    // ES3YUITest.g:1287:4: ({...}? block | statementTail )
                    int alt45 = 2;
                    try
                    {
                        DebugEnterSubRule(45);
                        try
                        {
                            DebugEnterDecision(45, false);
                            int LA45_1 = input.LA(1);

                            if ((LA45_1 == LBRACE))
                            {
                                int LA45_2 = input.LA(2);

                                if (((statement_stack.Peek().isBlock = input.LA(1) == LBRACE)))
                                {
                                    alt45 = 1;
                                }
                                else if ((true))
                                {
                                    alt45 = 2;
                                }
                                else
                                {
                                    NoViableAltException nvae = new NoViableAltException("", 45, 1, input, 2);
                                    DebugRecognitionException(nvae);
                                    throw nvae;
                                }
                            }
                            else if ((LA45_1 == ADD || LA45_1 == BREAK || LA45_1 == CONTINUE || LA45_1 == DEC || LA45_1 == DELETE || LA45_1 == DO || LA45_1 == DecimalLiteral || LA45_1 == FALSE || LA45_1 == FOR || LA45_1 == FUNCTION || (LA45_1 >= HexIntegerLiteral && LA45_1 <= IF) || LA45_1 == INC || LA45_1 == INV || LA45_1 == Identifier || LA45_1 == LBRACK || LA45_1 == LPAREN || (LA45_1 >= NEW && LA45_1 <= NOT) || LA45_1 == NULL || LA45_1 == OctalIntegerLiteral || LA45_1 == RETURN || LA45_1 == RegularExpressionLiteral || LA45_1 == SEMIC || LA45_1 == SUB || LA45_1 == SWITCH || LA45_1 == StringLiteral || (LA45_1 >= THIS && LA45_1 <= THROW) || (LA45_1 >= TRUE && LA45_1 <= TYPEOF) || (LA45_1 >= VAR && LA45_1 <= VOID) || (LA45_1 >= WHILE && LA45_1 <= WITH)))
                            {
                                alt45 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(45); }
                        switch (alt45)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1287:5: {...}? block
                                {
                                    DebugLocation(1287, 5);
                                    if (!((statement_stack.Peek().isBlock = input.LA(1) == LBRACE)))
                                    {
                                        throw new FailedPredicateException(input, "statement", " $statement::isBlock = input.LA(1) == LBRACE ");
                                    }
                                    DebugLocation(1287, 54);
                                    PushFollow(Follow._block_in_statement4391);
                                    block();
                                    PopFollow();


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // ES3YUITest.g:1287:62: statementTail
                                {
                                    DebugLocation(1287, 62);
                                    PushFollow(Follow._statementTail_in_statement4395);
                                    statementTail();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(45); }


                    // TEMPLATE REWRITE
                    // 1288:4: -> {instrument && !$statement::isBlock}? cover_line(src=$program::namecode=$textline=$start.Line)
                    if (instrument && !statement_stack.Peek().isBlock)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_line",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "line", retval.Start.Line } }
                    );
                    }

                    else // 1289:4: -> ignore(code=$text)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("ignore",
                        new Dictionary<string, object>() { { "code", input.ToString(retval.Start, input.LT(-1)) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);


                if (instrument && !statement_stack.Peek().isBlock)
                {
                    program_stack.Peek().executableLines.Add(retval.Start.Line);
                }
                if (Verbose)
                {
                    Console.WriteLine("\n[INFO] Instrumenting statement on line {0}", retval.Start.Line);
                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("statement", 48);
                LeaveRule("statement", 48);
                LeaveRule_statement();
                statement_scopeAfter(statement_stack.Peek()); statement_stack.Pop();
            }
            DebugLocation(1290, 1);
        }
        finally { DebugExitRule(GrammarFileName, "statement"); }
        return retval;

    }
    // $ANTLR end "statement"

    partial void EnterRule_statementTail();
    partial void LeaveRule_statementTail();
    // $ANTLR start "statementTail"
    // ES3YUITest.g:1292:1: statementTail : ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
    [GrammarRule("statementTail")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> statementTail()
    {
        EnterRule_statementTail();
        EnterRule("statementTail", 49);
        TraceIn("statementTail", 49);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "statementTail");
            DebugLocation(1292, 1);
            try
            {
                // ES3YUITest.g:1293:2: ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
                int alt46 = 13;
                try
                {
                    DebugEnterDecision(46, false);
                    switch (input.LA(1))
                    {
                        case VAR:
                            {
                                alt46 = 1;
                            }
                            break;
                        case SEMIC:
                            {
                                alt46 = 2;
                            }
                            break;
                        case ADD:
                        case DEC:
                        case DELETE:
                        case DecimalLiteral:
                        case FALSE:
                        case FUNCTION:
                        case HexIntegerLiteral:
                        case INC:
                        case INV:
                        case LBRACE:
                        case LBRACK:
                        case LPAREN:
                        case NEW:
                        case NOT:
                        case NULL:
                        case OctalIntegerLiteral:
                        case RegularExpressionLiteral:
                        case SUB:
                        case StringLiteral:
                        case THIS:
                        case TRUE:
                        case TYPEOF:
                        case VOID:
                            {
                                alt46 = 3;
                            }
                            break;
                        case Identifier:
                            {
                                int LA46_2 = input.LA(2);

                                if ((LA46_2 == COLON))
                                {
                                    alt46 = 10;
                                }
                                else if ((LA46_2 == EOF || (LA46_2 >= ADD && LA46_2 <= ANDASS) || LA46_2 == ASSIGN || LA46_2 == COMMA || LA46_2 == DEC || (LA46_2 >= DIV && LA46_2 <= DIVASS) || LA46_2 == DOT || (LA46_2 >= EOL && LA46_2 <= EQ) || (LA46_2 >= GT && LA46_2 <= GTE) || (LA46_2 >= IN && LA46_2 <= INSTANCEOF) || LA46_2 == LAND || LA46_2 == LBRACK || (LA46_2 >= LOR && LA46_2 <= LPAREN) || (LA46_2 >= LT && LA46_2 <= LTE) || (LA46_2 >= MOD && LA46_2 <= MultiLineComment) || LA46_2 == NEQ || LA46_2 == NSAME || (LA46_2 >= OR && LA46_2 <= ORASS) || (LA46_2 >= QUE && LA46_2 <= RBRACE) || (LA46_2 >= SAME && LA46_2 <= SHLASS) || (LA46_2 >= SHR && LA46_2 <= SHUASS) || (LA46_2 >= SUB && LA46_2 <= SUBASS) || (LA46_2 >= XOR && LA46_2 <= XORASS)))
                                {
                                    alt46 = 3;
                                }
                                else
                                {
                                    NoViableAltException nvae = new NoViableAltException("", 46, 4, input, 2);
                                    DebugRecognitionException(nvae);
                                    throw nvae;
                                }
                            }
                            break;
                        case IF:
                            {
                                alt46 = 4;
                            }
                            break;
                        case DO:
                        case FOR:
                        case WHILE:
                            {
                                alt46 = 5;
                            }
                            break;
                        case CONTINUE:
                            {
                                alt46 = 6;
                            }
                            break;
                        case BREAK:
                            {
                                alt46 = 7;
                            }
                            break;
                        case RETURN:
                            {
                                alt46 = 8;
                            }
                            break;
                        case WITH:
                            {
                                alt46 = 9;
                            }
                            break;
                        case SWITCH:
                            {
                                alt46 = 11;
                            }
                            break;
                        case THROW:
                            {
                                alt46 = 12;
                            }
                            break;
                        case TRY:
                            {
                                alt46 = 13;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(46); }
                switch (alt46)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1293:4: variableStatement
                        {
                            DebugLocation(1293, 4);
                            PushFollow(Follow._variableStatement_in_statementTail4443);
                            variableStatement();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1294:4: emptyStatement
                        {
                            DebugLocation(1294, 4);
                            PushFollow(Follow._emptyStatement_in_statementTail4448);
                            emptyStatement();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:1295:4: expressionStatement
                        {
                            DebugLocation(1295, 4);
                            PushFollow(Follow._expressionStatement_in_statementTail4453);
                            expressionStatement();
                            PopFollow();


                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // ES3YUITest.g:1296:4: ifStatement
                        {
                            DebugLocation(1296, 4);
                            PushFollow(Follow._ifStatement_in_statementTail4458);
                            ifStatement();
                            PopFollow();


                        }
                        break;
                    case 5:
                        DebugEnterAlt(5);
                        // ES3YUITest.g:1297:4: iterationStatement
                        {
                            DebugLocation(1297, 4);
                            PushFollow(Follow._iterationStatement_in_statementTail4463);
                            iterationStatement();
                            PopFollow();


                        }
                        break;
                    case 6:
                        DebugEnterAlt(6);
                        // ES3YUITest.g:1298:4: continueStatement
                        {
                            DebugLocation(1298, 4);
                            PushFollow(Follow._continueStatement_in_statementTail4468);
                            continueStatement();
                            PopFollow();


                        }
                        break;
                    case 7:
                        DebugEnterAlt(7);
                        // ES3YUITest.g:1299:4: breakStatement
                        {
                            DebugLocation(1299, 4);
                            PushFollow(Follow._breakStatement_in_statementTail4473);
                            breakStatement();
                            PopFollow();


                        }
                        break;
                    case 8:
                        DebugEnterAlt(8);
                        // ES3YUITest.g:1300:4: returnStatement
                        {
                            DebugLocation(1300, 4);
                            PushFollow(Follow._returnStatement_in_statementTail4478);
                            returnStatement();
                            PopFollow();


                        }
                        break;
                    case 9:
                        DebugEnterAlt(9);
                        // ES3YUITest.g:1301:4: withStatement
                        {
                            DebugLocation(1301, 4);
                            PushFollow(Follow._withStatement_in_statementTail4483);
                            withStatement();
                            PopFollow();


                        }
                        break;
                    case 10:
                        DebugEnterAlt(10);
                        // ES3YUITest.g:1302:4: labelledStatement
                        {
                            DebugLocation(1302, 4);
                            PushFollow(Follow._labelledStatement_in_statementTail4488);
                            labelledStatement();
                            PopFollow();


                        }
                        break;
                    case 11:
                        DebugEnterAlt(11);
                        // ES3YUITest.g:1303:4: switchStatement
                        {
                            DebugLocation(1303, 4);
                            PushFollow(Follow._switchStatement_in_statementTail4493);
                            switchStatement();
                            PopFollow();


                        }
                        break;
                    case 12:
                        DebugEnterAlt(12);
                        // ES3YUITest.g:1304:4: throwStatement
                        {
                            DebugLocation(1304, 4);
                            PushFollow(Follow._throwStatement_in_statementTail4498);
                            throwStatement();
                            PopFollow();


                        }
                        break;
                    case 13:
                        DebugEnterAlt(13);
                        // ES3YUITest.g:1305:4: tryStatement
                        {
                            DebugLocation(1305, 4);
                            PushFollow(Follow._tryStatement_in_statementTail4503);
                            tryStatement();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("statementTail", 49);
                LeaveRule("statementTail", 49);
                LeaveRule_statementTail();
            }
            DebugLocation(1306, 1);
        }
        finally { DebugExitRule(GrammarFileName, "statementTail"); }
        return retval;

    }
    // $ANTLR end "statementTail"

    partial void EnterRule_block();
    partial void LeaveRule_block();
    // $ANTLR start "block"
    // ES3YUITest.g:1310:1: block : lb= LBRACE ( statement )* RBRACE ;
    [GrammarRule("block")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> block()
    {
        EnterRule_block();
        EnterRule("block", 50);
        TraceIn("block", 50);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lb = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "block");
            DebugLocation(1310, 1);
            try
            {
                // ES3YUITest.g:1311:2: (lb= LBRACE ( statement )* RBRACE )
                DebugEnterAlt(1);
                // ES3YUITest.g:1311:4: lb= LBRACE ( statement )* RBRACE
                {
                    DebugLocation(1311, 6);
                    lb = (IToken)Match(input, LBRACE, Follow._LBRACE_in_block4518);
                    DebugLocation(1311, 14);
                    // ES3YUITest.g:1311:14: ( statement )*
                    try
                    {
                        DebugEnterSubRule(47);
                        while (true)
                        {
                            int alt47 = 2;
                            try
                            {
                                DebugEnterDecision(47, false);
                                int LA47_1 = input.LA(1);

                                if ((LA47_1 == ADD || LA47_1 == BREAK || LA47_1 == CONTINUE || LA47_1 == DEC || LA47_1 == DELETE || LA47_1 == DO || LA47_1 == DecimalLiteral || LA47_1 == FALSE || LA47_1 == FOR || LA47_1 == FUNCTION || (LA47_1 >= HexIntegerLiteral && LA47_1 <= IF) || LA47_1 == INC || LA47_1 == INV || LA47_1 == Identifier || (LA47_1 >= LBRACE && LA47_1 <= LBRACK) || LA47_1 == LPAREN || (LA47_1 >= NEW && LA47_1 <= NOT) || LA47_1 == NULL || LA47_1 == OctalIntegerLiteral || LA47_1 == RETURN || LA47_1 == RegularExpressionLiteral || LA47_1 == SEMIC || LA47_1 == SUB || LA47_1 == SWITCH || LA47_1 == StringLiteral || (LA47_1 >= THIS && LA47_1 <= THROW) || (LA47_1 >= TRUE && LA47_1 <= TYPEOF) || (LA47_1 >= VAR && LA47_1 <= VOID) || (LA47_1 >= WHILE && LA47_1 <= WITH)))
                                {
                                    alt47 = 1;
                                }


                            }
                            finally { DebugExitDecision(47); }
                            switch (alt47)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1311:14: statement
                                    {
                                        DebugLocation(1311, 14);
                                        PushFollow(Follow._statement_in_block4520);
                                        statement();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop47;
                            }
                        }

                    loop47:
                        ;

                    }
                    finally { DebugExitSubRule(47); }

                    DebugLocation(1311, 25);
                    Match(input, RBRACE, Follow._RBRACE_in_block4523);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("block", 50);
                LeaveRule("block", 50);
                LeaveRule_block();
            }
            DebugLocation(1313, 1);
        }
        finally { DebugExitRule(GrammarFileName, "block"); }
        return retval;

    }
    // $ANTLR end "block"

    partial void EnterRule_variableStatement();
    partial void LeaveRule_variableStatement();
    // $ANTLR start "variableStatement"
    // ES3YUITest.g:1319:1: variableStatement : VAR variableDeclaration ( COMMA variableDeclaration )* semic ;
    [GrammarRule("variableStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> variableStatement()
    {
        EnterRule_variableStatement();
        EnterRule("variableStatement", 51);
        TraceIn("variableStatement", 51);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "variableStatement");
            DebugLocation(1319, 1);
            try
            {
                // ES3YUITest.g:1320:2: ( VAR variableDeclaration ( COMMA variableDeclaration )* semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1320:4: VAR variableDeclaration ( COMMA variableDeclaration )* semic
                {
                    DebugLocation(1320, 4);
                    Match(input, VAR, Follow._VAR_in_variableStatement4541);
                    DebugLocation(1320, 8);
                    PushFollow(Follow._variableDeclaration_in_variableStatement4543);
                    variableDeclaration();
                    PopFollow();

                    DebugLocation(1320, 28);
                    // ES3YUITest.g:1320:28: ( COMMA variableDeclaration )*
                    try
                    {
                        DebugEnterSubRule(48);
                        while (true)
                        {
                            int alt48 = 2;
                            try
                            {
                                DebugEnterDecision(48, false);
                                int LA48_1 = input.LA(1);

                                if ((LA48_1 == COMMA))
                                {
                                    alt48 = 1;
                                }


                            }
                            finally { DebugExitDecision(48); }
                            switch (alt48)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1320:30: COMMA variableDeclaration
                                    {
                                        DebugLocation(1320, 30);
                                        Match(input, COMMA, Follow._COMMA_in_variableStatement4547);
                                        DebugLocation(1320, 36);
                                        PushFollow(Follow._variableDeclaration_in_variableStatement4549);
                                        variableDeclaration();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop48;
                            }
                        }

                    loop48:
                        ;

                    }
                    finally { DebugExitSubRule(48); }

                    DebugLocation(1320, 59);
                    PushFollow(Follow._semic_in_variableStatement4554);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("variableStatement", 51);
                LeaveRule("variableStatement", 51);
                LeaveRule_variableStatement();
            }
            DebugLocation(1322, 1);
        }
        finally { DebugExitRule(GrammarFileName, "variableStatement"); }
        return retval;

    }
    // $ANTLR end "variableStatement"

    partial void EnterRule_variableDeclaration();
    partial void LeaveRule_variableDeclaration();
    // $ANTLR start "variableDeclaration"
    // ES3YUITest.g:1324:1: variableDeclaration : Identifier ( ASSIGN assignmentExpression )? ;
    [GrammarRule("variableDeclaration")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> variableDeclaration()
    {
        EnterRule_variableDeclaration();
        EnterRule("variableDeclaration", 52);
        TraceIn("variableDeclaration", 52);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "variableDeclaration");
            DebugLocation(1324, 1);
            try
            {
                // ES3YUITest.g:1325:2: ( Identifier ( ASSIGN assignmentExpression )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1325:4: Identifier ( ASSIGN assignmentExpression )?
                {
                    DebugLocation(1325, 4);
                    Match(input, Identifier, Follow._Identifier_in_variableDeclaration4567);
                    DebugLocation(1325, 15);
                    // ES3YUITest.g:1325:15: ( ASSIGN assignmentExpression )?
                    int alt49 = 2;
                    try
                    {
                        DebugEnterSubRule(49);
                        try
                        {
                            DebugEnterDecision(49, false);
                            int LA49_1 = input.LA(1);

                            if ((LA49_1 == ASSIGN))
                            {
                                alt49 = 1;
                            }
                        }
                        finally { DebugExitDecision(49); }
                        switch (alt49)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1325:17: ASSIGN assignmentExpression
                                {
                                    DebugLocation(1325, 17);
                                    Match(input, ASSIGN, Follow._ASSIGN_in_variableDeclaration4571);
                                    DebugLocation(1325, 24);
                                    PushFollow(Follow._assignmentExpression_in_variableDeclaration4573);
                                    assignmentExpression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(49); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("variableDeclaration", 52);
                LeaveRule("variableDeclaration", 52);
                LeaveRule_variableDeclaration();
            }
            DebugLocation(1326, 1);
        }
        finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
        return retval;

    }
    // $ANTLR end "variableDeclaration"

    partial void EnterRule_variableDeclarationNoIn();
    partial void LeaveRule_variableDeclarationNoIn();
    // $ANTLR start "variableDeclarationNoIn"
    // ES3YUITest.g:1328:1: variableDeclarationNoIn : Identifier ( ASSIGN assignmentExpressionNoIn )? ;
    [GrammarRule("variableDeclarationNoIn")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> variableDeclarationNoIn()
    {
        EnterRule_variableDeclarationNoIn();
        EnterRule("variableDeclarationNoIn", 53);
        TraceIn("variableDeclarationNoIn", 53);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
            DebugLocation(1328, 1);
            try
            {
                // ES3YUITest.g:1329:2: ( Identifier ( ASSIGN assignmentExpressionNoIn )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1329:4: Identifier ( ASSIGN assignmentExpressionNoIn )?
                {
                    DebugLocation(1329, 4);
                    Match(input, Identifier, Follow._Identifier_in_variableDeclarationNoIn4588);
                    DebugLocation(1329, 15);
                    // ES3YUITest.g:1329:15: ( ASSIGN assignmentExpressionNoIn )?
                    int alt50 = 2;
                    try
                    {
                        DebugEnterSubRule(50);
                        try
                        {
                            DebugEnterDecision(50, false);
                            int LA50_1 = input.LA(1);

                            if ((LA50_1 == ASSIGN))
                            {
                                alt50 = 1;
                            }
                        }
                        finally { DebugExitDecision(50); }
                        switch (alt50)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1329:17: ASSIGN assignmentExpressionNoIn
                                {
                                    DebugLocation(1329, 17);
                                    Match(input, ASSIGN, Follow._ASSIGN_in_variableDeclarationNoIn4592);
                                    DebugLocation(1329, 24);
                                    PushFollow(Follow._assignmentExpressionNoIn_in_variableDeclarationNoIn4594);
                                    assignmentExpressionNoIn();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(50); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("variableDeclarationNoIn", 53);
                LeaveRule("variableDeclarationNoIn", 53);
                LeaveRule_variableDeclarationNoIn();
            }
            DebugLocation(1330, 1);
        }
        finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
        return retval;

    }
    // $ANTLR end "variableDeclarationNoIn"

    partial void EnterRule_emptyStatement();
    partial void LeaveRule_emptyStatement();
    // $ANTLR start "emptyStatement"
    // ES3YUITest.g:1336:1: emptyStatement : SEMIC ;
    [GrammarRule("emptyStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> emptyStatement()
    {
        EnterRule_emptyStatement();
        EnterRule("emptyStatement", 54);
        TraceIn("emptyStatement", 54);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "emptyStatement");
            DebugLocation(1336, 1);
            try
            {
                // ES3YUITest.g:1337:2: ( SEMIC )
                DebugEnterAlt(1);
                // ES3YUITest.g:1337:4: SEMIC
                {
                    DebugLocation(1337, 4);
                    Match(input, SEMIC, Follow._SEMIC_in_emptyStatement4613);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("emptyStatement", 54);
                LeaveRule("emptyStatement", 54);
                LeaveRule_emptyStatement();
            }
            DebugLocation(1338, 1);
        }
        finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
        return retval;

    }
    // $ANTLR end "emptyStatement"

    partial void EnterRule_expressionStatement();
    partial void LeaveRule_expressionStatement();
    // $ANTLR start "expressionStatement"
    // ES3YUITest.g:1350:1: expressionStatement : expression semic ;
    [GrammarRule("expressionStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> expressionStatement()
    {
        EnterRule_expressionStatement();
        EnterRule("expressionStatement", 55);
        TraceIn("expressionStatement", 55);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "expressionStatement");
            DebugLocation(1350, 1);
            try
            {
                // ES3YUITest.g:1351:2: ( expression semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1351:4: expression semic
                {
                    DebugLocation(1351, 4);
                    PushFollow(Follow._expression_in_expressionStatement4631);
                    expression();
                    PopFollow();

                    DebugLocation(1351, 15);
                    PushFollow(Follow._semic_in_expressionStatement4633);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("expressionStatement", 55);
                LeaveRule("expressionStatement", 55);
                LeaveRule_expressionStatement();
            }
            DebugLocation(1352, 1);
        }
        finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
        return retval;

    }
    // $ANTLR end "expressionStatement"

    partial void EnterRule_ifStatement();
    partial void LeaveRule_ifStatement();
    // $ANTLR start "ifStatement"
    // ES3YUITest.g:1359:1: ifStatement : IF LPAREN expression RPAREN statement ({...}? elseStatement )? -> template(p=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)body=WrapInBraces($statement.start, $statement.stop, input)elseClause=\r\n\t $elseStatement.stop != null ? input.ToString($statement.stop.TokenIndex+1, $elseStatement.stop.TokenIndex ) : null) \"<p><body><elseClause>\";
    [GrammarRule("ifStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> ifStatement()
    {
        EnterRule_ifStatement();
        EnterRule("ifStatement", 56);
        TraceIn("ifStatement", 56);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> statement1 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> elseStatement2 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "ifStatement");
            DebugLocation(1359, 1);
            try
            {
                // ES3YUITest.g:1361:2: ( IF LPAREN expression RPAREN statement ({...}? elseStatement )? -> template(p=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)body=WrapInBraces($statement.start, $statement.stop, input)elseClause=\r\n\t $elseStatement.stop != null ? input.ToString($statement.stop.TokenIndex+1, $elseStatement.stop.TokenIndex ) : null) \"<p><body><elseClause>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1361:4: IF LPAREN expression RPAREN statement ({...}? elseStatement )?
                {
                    DebugLocation(1361, 4);
                    Match(input, IF, Follow._IF_in_ifStatement4651);
                    DebugLocation(1361, 7);
                    Match(input, LPAREN, Follow._LPAREN_in_ifStatement4653);
                    DebugLocation(1361, 14);
                    PushFollow(Follow._expression_in_ifStatement4655);
                    expression();
                    PopFollow();

                    DebugLocation(1361, 25);
                    Match(input, RPAREN, Follow._RPAREN_in_ifStatement4657);
                    DebugLocation(1361, 32);
                    PushFollow(Follow._statement_in_ifStatement4659);
                    statement1 = statement();
                    PopFollow();

                    DebugLocation(1361, 42);
                    // ES3YUITest.g:1361:42: ({...}? elseStatement )?
                    int alt51 = 2;
                    try
                    {
                        DebugEnterSubRule(51);
                        try
                        {
                            DebugEnterDecision(51, false);
                            int LA51_1 = input.LA(1);

                            if ((LA51_1 == ELSE))
                            {
                                int LA51_2 = input.LA(2);

                                if (((input.LA(1) == ELSE)))
                                {
                                    alt51 = 1;
                                }
                            }
                        }
                        finally { DebugExitDecision(51); }
                        switch (alt51)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1361:44: {...}? elseStatement
                                {
                                    DebugLocation(1361, 44);
                                    if (!((input.LA(1) == ELSE)))
                                    {
                                        throw new FailedPredicateException(input, "ifStatement", " input.LA(1) == ELSE ");
                                    }
                                    DebugLocation(1361, 69);
                                    PushFollow(Follow._elseStatement_in_ifStatement4665);
                                    elseStatement2 = elseStatement();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(51); }


                    // TEMPLATE REWRITE
                    // 1363:2: -> template(p=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)body=WrapInBraces($statement.start, $statement.stop, input)elseClause=\r\n\t $elseStatement.stop != null ? input.ToString($statement.stop.TokenIndex+1, $elseStatement.stop.TokenIndex ) : null) \"<p><body><elseClause>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<p><body><else>",//"Clause>",
                        new Dictionary<string, object>() { {"p", input.ToString(retval.Start.TokenIndex, (statement1!=null?((IToken)statement1.Start):default(IToken)).TokenIndex - 1)}, {"body", WrapInBraces((statement1!=null?((IToken)statement1.Start):default(IToken)), (statement1!=null?((IToken)statement1.Stop):default(IToken)), input)}, {"else",//"Clause", 
				             (elseStatement2!=null?((IToken)elseStatement2.Stop):default(IToken)) != null ? input.ToString((statement1!=null?((IToken)statement1.Stop):default(IToken)).TokenIndex+1, (elseStatement2!=null?((IToken)elseStatement2.Stop):default(IToken)).TokenIndex ) : null} }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("ifStatement", 56);
                LeaveRule("ifStatement", 56);
                LeaveRule_ifStatement();
            }
            DebugLocation(1367, 1);
        }
        finally { DebugExitRule(GrammarFileName, "ifStatement"); }
        return retval;

    }
    // $ANTLR end "ifStatement"

    partial void EnterRule_elseStatement();
    partial void LeaveRule_elseStatement();
    // $ANTLR start "elseStatement"
    // ES3YUITest.g:1369:1: elseStatement : ELSE statement -> template(prefix=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<prefix><stmt>\";
    [GrammarRule("elseStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> elseStatement()
    {
        EnterRule_elseStatement();
        EnterRule("elseStatement", 57);
        TraceIn("elseStatement", 57);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> statement3 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "elseStatement");
            DebugLocation(1369, 1);
            try
            {
                // ES3YUITest.g:1370:2: ( ELSE statement -> template(prefix=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<prefix><stmt>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1370:4: ELSE statement
                {
                    DebugLocation(1370, 4);
                    Match(input, ELSE, Follow._ELSE_in_elseStatement4737);
                    DebugLocation(1370, 9);
                    PushFollow(Follow._statement_in_elseStatement4739);
                    statement3 = statement();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1371:2: -> template(prefix=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<prefix><stmt>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<prefix><stmt>",
                        new Dictionary<string, object>() { { "prefix", input.ToString(retval.Start.TokenIndex, (statement3 != null ? ((IToken)statement3.Start) : default(IToken)).TokenIndex - 1) }, { "stmt", WrapInBraces((statement3 != null ? ((IToken)statement3.Start) : default(IToken)), (statement3 != null ? ((IToken)statement3.Stop) : default(IToken)), input) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("elseStatement", 57);
                LeaveRule("elseStatement", 57);
                LeaveRule_elseStatement();
            }
            DebugLocation(1372, 1);
        }
        finally { DebugExitRule(GrammarFileName, "elseStatement"); }
        return retval;

    }
    // $ANTLR end "elseStatement"

    partial void EnterRule_iterationStatement();
    partial void LeaveRule_iterationStatement();
    // $ANTLR start "iterationStatement"
    // ES3YUITest.g:1378:1: iterationStatement : ( doStatement | whileStatement | forStatement );
    [GrammarRule("iterationStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> iterationStatement()
    {
        EnterRule_iterationStatement();
        EnterRule("iterationStatement", 58);
        TraceIn("iterationStatement", 58);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "iterationStatement");
            DebugLocation(1378, 1);
            try
            {
                // ES3YUITest.g:1379:2: ( doStatement | whileStatement | forStatement )
                int alt52 = 3;
                try
                {
                    DebugEnterDecision(52, false);
                    switch (input.LA(1))
                    {
                        case DO:
                            {
                                alt52 = 1;
                            }
                            break;
                        case WHILE:
                            {
                                alt52 = 2;
                            }
                            break;
                        case FOR:
                            {
                                alt52 = 3;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 52, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(52); }
                switch (alt52)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1379:4: doStatement
                        {
                            DebugLocation(1379, 4);
                            PushFollow(Follow._doStatement_in_iterationStatement4776);
                            doStatement();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1380:4: whileStatement
                        {
                            DebugLocation(1380, 4);
                            PushFollow(Follow._whileStatement_in_iterationStatement4781);
                            whileStatement();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:1381:4: forStatement
                        {
                            DebugLocation(1381, 4);
                            PushFollow(Follow._forStatement_in_iterationStatement4786);
                            forStatement();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("iterationStatement", 58);
                LeaveRule("iterationStatement", 58);
                LeaveRule_iterationStatement();
            }
            DebugLocation(1382, 1);
        }
        finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
        return retval;

    }
    // $ANTLR end "iterationStatement"

    partial void EnterRule_doStatement();
    partial void LeaveRule_doStatement();
    // $ANTLR start "doStatement"
    // ES3YUITest.g:1384:1: doStatement : DO statement WHILE LPAREN expression RPAREN semic -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)post=input.ToString($WHILE, $RPAREN)end=$semic.text) \"<pre><stmt><post><end>\";
    [GrammarRule("doStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> doStatement()
    {
        EnterRule_doStatement();
        EnterRule("doStatement", 59);
        TraceIn("doStatement", 59);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken WHILE5 = default(IToken);
        IToken RPAREN6 = default(IToken);
        TemplateParserRuleReturnScope<StringTemplate, IToken> statement4 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> semic7 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "doStatement");
            DebugLocation(1384, 1);
            try
            {
                // ES3YUITest.g:1385:2: ( DO statement WHILE LPAREN expression RPAREN semic -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)post=input.ToString($WHILE, $RPAREN)end=$semic.text) \"<pre><stmt><post><end>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1385:4: DO statement WHILE LPAREN expression RPAREN semic
                {
                    DebugLocation(1385, 4);
                    Match(input, DO, Follow._DO_in_doStatement4798);
                    DebugLocation(1385, 7);
                    PushFollow(Follow._statement_in_doStatement4800);
                    statement4 = statement();
                    PopFollow();

                    DebugLocation(1385, 17);
                    WHILE5 = (IToken)Match(input, WHILE, Follow._WHILE_in_doStatement4802);
                    DebugLocation(1385, 23);
                    Match(input, LPAREN, Follow._LPAREN_in_doStatement4804);
                    DebugLocation(1385, 30);
                    PushFollow(Follow._expression_in_doStatement4806);
                    expression();
                    PopFollow();

                    DebugLocation(1385, 41);
                    RPAREN6 = (IToken)Match(input, RPAREN, Follow._RPAREN_in_doStatement4808);
                    DebugLocation(1385, 48);
                    PushFollow(Follow._semic_in_doStatement4810);
                    semic7 = semic();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1386:2: -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)post=input.ToString($WHILE, $RPAREN)end=$semic.text) \"<pre><stmt><post><end>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<pre><stmt><post><end>",
                        new Dictionary<string, object>() { { "pre", input.ToString(retval.Start.TokenIndex, (statement4 != null ? ((IToken)statement4.Start) : default(IToken)).TokenIndex - 1) }, { "stmt", WrapInBraces((statement4 != null ? ((IToken)statement4.Start) : default(IToken)), (statement4 != null ? ((IToken)statement4.Stop) : default(IToken)), input) }, { "post", input.ToString(WHILE5, RPAREN6) }, { "end", (semic7 != null ? input.ToString(semic7.Start, semic7.Stop) : default(string)) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("doStatement", 59);
                LeaveRule("doStatement", 59);
                LeaveRule_doStatement();
            }
            DebugLocation(1390, 1);
        }
        finally { DebugExitRule(GrammarFileName, "doStatement"); }
        return retval;

    }
    // $ANTLR end "doStatement"

    partial void EnterRule_whileStatement();
    partial void LeaveRule_whileStatement();
    // $ANTLR start "whileStatement"
    // ES3YUITest.g:1392:1: whileStatement : WHILE LPAREN expression RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\";
    [GrammarRule("whileStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> whileStatement()
    {
        EnterRule_whileStatement();
        EnterRule("whileStatement", 60);
        TraceIn("whileStatement", 60);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> statement8 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "whileStatement");
            DebugLocation(1392, 1);
            try
            {
                // ES3YUITest.g:1393:2: ( WHILE LPAREN expression RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1393:4: WHILE LPAREN expression RPAREN statement
                {
                    DebugLocation(1393, 4);
                    Match(input, WHILE, Follow._WHILE_in_whileStatement4896);
                    DebugLocation(1393, 10);
                    Match(input, LPAREN, Follow._LPAREN_in_whileStatement4898);
                    DebugLocation(1393, 17);
                    PushFollow(Follow._expression_in_whileStatement4900);
                    expression();
                    PopFollow();

                    DebugLocation(1393, 28);
                    Match(input, RPAREN, Follow._RPAREN_in_whileStatement4902);
                    DebugLocation(1393, 35);
                    PushFollow(Follow._statement_in_whileStatement4904);
                    statement8 = statement();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1394:2: -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<pre><stmt>",
                        new Dictionary<string, object>() { { "pre", input.ToString(retval.Start.TokenIndex, (statement8 != null ? ((IToken)statement8.Start) : default(IToken)).TokenIndex - 1) }, { "stmt", WrapInBraces((statement8 != null ? ((IToken)statement8.Start) : default(IToken)), (statement8 != null ? ((IToken)statement8.Stop) : default(IToken)), input) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("whileStatement", 60);
                LeaveRule("whileStatement", 60);
                LeaveRule_whileStatement();
            }
            DebugLocation(1397, 1);
        }
        finally { DebugExitRule(GrammarFileName, "whileStatement"); }
        return retval;

    }
    // $ANTLR end "whileStatement"

    partial void EnterRule_forStatement();
    partial void LeaveRule_forStatement();
    // $ANTLR start "forStatement"
    // ES3YUITest.g:1440:1: forStatement : FOR LPAREN forControl RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\";
    [GrammarRule("forStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> forStatement()
    {
        EnterRule_forStatement();
        EnterRule("forStatement", 61);
        TraceIn("forStatement", 61);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> statement9 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "forStatement");
            DebugLocation(1440, 1);
            try
            {
                // ES3YUITest.g:1441:2: ( FOR LPAREN forControl RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1441:4: FOR LPAREN forControl RPAREN statement
                {
                    DebugLocation(1441, 4);
                    Match(input, FOR, Follow._FOR_in_forStatement4965);
                    DebugLocation(1441, 8);
                    Match(input, LPAREN, Follow._LPAREN_in_forStatement4967);
                    DebugLocation(1441, 15);
                    PushFollow(Follow._forControl_in_forStatement4969);
                    forControl();
                    PopFollow();

                    DebugLocation(1441, 26);
                    Match(input, RPAREN, Follow._RPAREN_in_forStatement4971);
                    DebugLocation(1441, 33);
                    PushFollow(Follow._statement_in_forStatement4973);
                    statement9 = statement();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1442:2: -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<pre><stmt>",
                        new Dictionary<string, object>() { { "pre", input.ToString(retval.Start.TokenIndex, (statement9 != null ? ((IToken)statement9.Start) : default(IToken)).TokenIndex - 1) }, { "stmt", WrapInBraces((statement9 != null ? ((IToken)statement9.Start) : default(IToken)), (statement9 != null ? ((IToken)statement9.Stop) : default(IToken)), input) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("forStatement", 61);
                LeaveRule("forStatement", 61);
                LeaveRule_forStatement();
            }
            DebugLocation(1445, 1);
        }
        finally { DebugExitRule(GrammarFileName, "forStatement"); }
        return retval;

    }
    // $ANTLR end "forStatement"

    partial void EnterRule_forControl();
    partial void LeaveRule_forControl();
    // $ANTLR start "forControl"
    // ES3YUITest.g:1447:1: forControl : ( forControlVar | forControlExpression | forControlSemic );
    [GrammarRule("forControl")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> forControl()
    {
        EnterRule_forControl();
        EnterRule("forControl", 62);
        TraceIn("forControl", 62);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "forControl");
            DebugLocation(1447, 1);
            try
            {
                // ES3YUITest.g:1448:2: ( forControlVar | forControlExpression | forControlSemic )
                int alt53 = 3;
                try
                {
                    DebugEnterDecision(53, false);
                    switch (input.LA(1))
                    {
                        case VAR:
                            {
                                alt53 = 1;
                            }
                            break;
                        case ADD:
                        case DEC:
                        case DELETE:
                        case DecimalLiteral:
                        case FALSE:
                        case FUNCTION:
                        case HexIntegerLiteral:
                        case INC:
                        case INV:
                        case Identifier:
                        case LBRACE:
                        case LBRACK:
                        case LPAREN:
                        case NEW:
                        case NOT:
                        case NULL:
                        case OctalIntegerLiteral:
                        case RegularExpressionLiteral:
                        case SUB:
                        case StringLiteral:
                        case THIS:
                        case TRUE:
                        case TYPEOF:
                        case VOID:
                            {
                                alt53 = 2;
                            }
                            break;
                        case SEMIC:
                            {
                                alt53 = 3;
                            }
                            break;
                        default:
                            {
                                NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                    }

                }
                finally { DebugExitDecision(53); }
                switch (alt53)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1448:4: forControlVar
                        {
                            DebugLocation(1448, 4);
                            PushFollow(Follow._forControlVar_in_forControl5032);
                            forControlVar();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1449:4: forControlExpression
                        {
                            DebugLocation(1449, 4);
                            PushFollow(Follow._forControlExpression_in_forControl5037);
                            forControlExpression();
                            PopFollow();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // ES3YUITest.g:1450:4: forControlSemic
                        {
                            DebugLocation(1450, 4);
                            PushFollow(Follow._forControlSemic_in_forControl5042);
                            forControlSemic();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("forControl", 62);
                LeaveRule("forControl", 62);
                LeaveRule_forControl();
            }
            DebugLocation(1451, 1);
        }
        finally { DebugExitRule(GrammarFileName, "forControl"); }
        return retval;

    }
    // $ANTLR end "forControl"

    partial void EnterRule_forControlVar();
    partial void LeaveRule_forControlVar();
    // $ANTLR start "forControlVar"
    // ES3YUITest.g:1453:1: forControlVar : VAR variableDeclarationNoIn ( ( IN expression ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) ) ;
    [GrammarRule("forControlVar")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> forControlVar()
    {
        EnterRule_forControlVar();
        EnterRule("forControlVar", 63);
        TraceIn("forControlVar", 63);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> ex1 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> ex2 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "forControlVar");
            DebugLocation(1453, 1);
            try
            {
                // ES3YUITest.g:1454:2: ( VAR variableDeclarationNoIn ( ( IN expression ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) ) )
                DebugEnterAlt(1);
                // ES3YUITest.g:1454:4: VAR variableDeclarationNoIn ( ( IN expression ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) )
                {
                    DebugLocation(1454, 4);
                    Match(input, VAR, Follow._VAR_in_forControlVar5053);
                    DebugLocation(1454, 8);
                    PushFollow(Follow._variableDeclarationNoIn_in_forControlVar5055);
                    variableDeclarationNoIn();
                    PopFollow();

                    DebugLocation(1455, 2);
                    // ES3YUITest.g:1455:2: ( ( IN expression ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) )
                    int alt57 = 2;
                    try
                    {
                        DebugEnterSubRule(57);
                        try
                        {
                            DebugEnterDecision(57, false);
                            int LA57_1 = input.LA(1);

                            if ((LA57_1 == IN))
                            {
                                alt57 = 1;
                            }
                            else if ((LA57_1 == COMMA || LA57_1 == SEMIC))
                            {
                                alt57 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(57); }
                        switch (alt57)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1456:3: ( IN expression )
                                {
                                    DebugLocation(1456, 3);
                                    // ES3YUITest.g:1456:3: ( IN expression )
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1457:4: IN expression
                                    {
                                        DebugLocation(1457, 4);
                                        Match(input, IN, Follow._IN_in_forControlVar5067);
                                        DebugLocation(1457, 7);
                                        PushFollow(Follow._expression_in_forControlVar5069);
                                        expression();
                                        PopFollow();


                                    }


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // ES3YUITest.g:1461:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
                                {
                                    DebugLocation(1461, 3);
                                    // ES3YUITest.g:1461:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1462:4: ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )?
                                    {
                                        DebugLocation(1462, 4);
                                        // ES3YUITest.g:1462:4: ( COMMA variableDeclarationNoIn )*
                                        try
                                        {
                                            DebugEnterSubRule(54);
                                            while (true)
                                            {
                                                int alt54 = 2;
                                                try
                                                {
                                                    DebugEnterDecision(54, false);
                                                    int LA54_1 = input.LA(1);

                                                    if ((LA54_1 == COMMA))
                                                    {
                                                        alt54 = 1;
                                                    }


                                                }
                                                finally { DebugExitDecision(54); }
                                                switch (alt54)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // ES3YUITest.g:1462:6: COMMA variableDeclarationNoIn
                                                        {
                                                            DebugLocation(1462, 6);
                                                            Match(input, COMMA, Follow._COMMA_in_forControlVar5092);
                                                            DebugLocation(1462, 12);
                                                            PushFollow(Follow._variableDeclarationNoIn_in_forControlVar5094);
                                                            variableDeclarationNoIn();
                                                            PopFollow();


                                                        }
                                                        break;

                                                    default:
                                                        goto loop54;
                                                }
                                            }

                                        loop54:
                                            ;

                                        }
                                        finally { DebugExitSubRule(54); }

                                        DebugLocation(1462, 39);
                                        Match(input, SEMIC, Follow._SEMIC_in_forControlVar5099);
                                        DebugLocation(1462, 48);
                                        // ES3YUITest.g:1462:48: (ex1= expression )?
                                        int alt55 = 2;
                                        try
                                        {
                                            DebugEnterSubRule(55);
                                            try
                                            {
                                                DebugEnterDecision(55, false);
                                                int LA55_1 = input.LA(1);

                                                if ((LA55_1 == ADD || LA55_1 == DEC || LA55_1 == DELETE || LA55_1 == DecimalLiteral || LA55_1 == FALSE || LA55_1 == FUNCTION || LA55_1 == HexIntegerLiteral || LA55_1 == INC || LA55_1 == INV || LA55_1 == Identifier || (LA55_1 >= LBRACE && LA55_1 <= LBRACK) || LA55_1 == LPAREN || (LA55_1 >= NEW && LA55_1 <= NOT) || LA55_1 == NULL || LA55_1 == OctalIntegerLiteral || LA55_1 == RegularExpressionLiteral || LA55_1 == SUB || LA55_1 == StringLiteral || LA55_1 == THIS || LA55_1 == TRUE || LA55_1 == TYPEOF || LA55_1 == VOID))
                                                {
                                                    alt55 = 1;
                                                }
                                            }
                                            finally { DebugExitDecision(55); }
                                            switch (alt55)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:1462:48: ex1= expression
                                                    {
                                                        DebugLocation(1462, 48);
                                                        PushFollow(Follow._expression_in_forControlVar5103);
                                                        ex1 = expression();
                                                        PopFollow();


                                                    }
                                                    break;

                                            }
                                        }
                                        finally { DebugExitSubRule(55); }

                                        DebugLocation(1462, 61);
                                        Match(input, SEMIC, Follow._SEMIC_in_forControlVar5106);
                                        DebugLocation(1462, 70);
                                        // ES3YUITest.g:1462:70: (ex2= expression )?
                                        int alt56 = 2;
                                        try
                                        {
                                            DebugEnterSubRule(56);
                                            try
                                            {
                                                DebugEnterDecision(56, false);
                                                int LA56_1 = input.LA(1);

                                                if ((LA56_1 == ADD || LA56_1 == DEC || LA56_1 == DELETE || LA56_1 == DecimalLiteral || LA56_1 == FALSE || LA56_1 == FUNCTION || LA56_1 == HexIntegerLiteral || LA56_1 == INC || LA56_1 == INV || LA56_1 == Identifier || (LA56_1 >= LBRACE && LA56_1 <= LBRACK) || LA56_1 == LPAREN || (LA56_1 >= NEW && LA56_1 <= NOT) || LA56_1 == NULL || LA56_1 == OctalIntegerLiteral || LA56_1 == RegularExpressionLiteral || LA56_1 == SUB || LA56_1 == StringLiteral || LA56_1 == THIS || LA56_1 == TRUE || LA56_1 == TYPEOF || LA56_1 == VOID))
                                                {
                                                    alt56 = 1;
                                                }
                                            }
                                            finally { DebugExitDecision(56); }
                                            switch (alt56)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:1462:70: ex2= expression
                                                    {
                                                        DebugLocation(1462, 70);
                                                        PushFollow(Follow._expression_in_forControlVar5110);
                                                        ex2 = expression();
                                                        PopFollow();


                                                    }
                                                    break;

                                            }
                                        }
                                        finally { DebugExitSubRule(56); }


                                    }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(57); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("forControlVar", 63);
                LeaveRule("forControlVar", 63);
                LeaveRule_forControlVar();
            }
            DebugLocation(1466, 1);
        }
        finally { DebugExitRule(GrammarFileName, "forControlVar"); }
        return retval;

    }
    // $ANTLR end "forControlVar"

    partial void EnterRule_forControlExpression();
    partial void LeaveRule_forControlExpression();
    // $ANTLR start "forControlExpression"
    // ES3YUITest.g:1468:1: forControlExpression : ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) ) ;
    [GrammarRule("forControlExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> forControlExpression()
    {
        EnterRule_forControlExpression();
        EnterRule("forControlExpression", 64);
        TraceIn("forControlExpression", 64);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> ex1 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> ex2 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> ex3 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);


        Object[] isLhs = new Object[1];

        try
        {
            DebugEnterRule(GrammarFileName, "forControlExpression");
            DebugLocation(1468, 1);
            try
            {
                // ES3YUITest.g:1473:2: (ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) ) )
                DebugEnterAlt(1);
                // ES3YUITest.g:1473:4: ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) )
                {
                    DebugLocation(1473, 7);
                    PushFollow(Follow._expressionNoIn_in_forControlExpression5140);
                    ex1 = expressionNoIn();
                    PopFollow();

                    DebugLocation(1474, 2);
                    // ES3YUITest.g:1474:2: ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) )
                    int alt60 = 2;
                    try
                    {
                        DebugEnterSubRule(60);
                        try
                        {
                            DebugEnterDecision(60, false);
                            int LA60_1 = input.LA(1);

                            if ((LA60_1 == IN))
                            {
                                alt60 = 1;
                            }
                            else if ((LA60_1 == SEMIC))
                            {
                                alt60 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 60, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(60); }
                        switch (alt60)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1475:3: {...}? ( IN ex2= expression )
                                {
                                    DebugLocation(1475, 3);
                                    if (!((IsLeftHandSideIn(ex1, isLhs))))
                                    {
                                        throw new FailedPredicateException(input, "forControlExpression", " IsLeftHandSideIn(ex1, isLhs) ");
                                    }
                                    DebugLocation(1475, 37);
                                    // ES3YUITest.g:1475:37: ( IN ex2= expression )
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1476:4: IN ex2= expression
                                    {
                                        DebugLocation(1476, 4);
                                        Match(input, IN, Follow._IN_in_forControlExpression5155);
                                        DebugLocation(1476, 10);
                                        PushFollow(Follow._expression_in_forControlExpression5159);
                                        ex2 = expression();
                                        PopFollow();


                                    }


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // ES3YUITest.g:1480:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? )
                                {
                                    DebugLocation(1480, 3);
                                    // ES3YUITest.g:1480:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? )
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1481:4: SEMIC (ex2= expression )? SEMIC (ex3= expression )?
                                    {
                                        DebugLocation(1481, 4);
                                        Match(input, SEMIC, Follow._SEMIC_in_forControlExpression5180);
                                        DebugLocation(1481, 13);
                                        // ES3YUITest.g:1481:13: (ex2= expression )?
                                        int alt58 = 2;
                                        try
                                        {
                                            DebugEnterSubRule(58);
                                            try
                                            {
                                                DebugEnterDecision(58, false);
                                                int LA58_1 = input.LA(1);

                                                if ((LA58_1 == ADD || LA58_1 == DEC || LA58_1 == DELETE || LA58_1 == DecimalLiteral || LA58_1 == FALSE || LA58_1 == FUNCTION || LA58_1 == HexIntegerLiteral || LA58_1 == INC || LA58_1 == INV || LA58_1 == Identifier || (LA58_1 >= LBRACE && LA58_1 <= LBRACK) || LA58_1 == LPAREN || (LA58_1 >= NEW && LA58_1 <= NOT) || LA58_1 == NULL || LA58_1 == OctalIntegerLiteral || LA58_1 == RegularExpressionLiteral || LA58_1 == SUB || LA58_1 == StringLiteral || LA58_1 == THIS || LA58_1 == TRUE || LA58_1 == TYPEOF || LA58_1 == VOID))
                                                {
                                                    alt58 = 1;
                                                }
                                            }
                                            finally { DebugExitDecision(58); }
                                            switch (alt58)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:1481:13: ex2= expression
                                                    {
                                                        DebugLocation(1481, 13);
                                                        PushFollow(Follow._expression_in_forControlExpression5184);
                                                        ex2 = expression();
                                                        PopFollow();


                                                    }
                                                    break;

                                            }
                                        }
                                        finally { DebugExitSubRule(58); }

                                        DebugLocation(1481, 26);
                                        Match(input, SEMIC, Follow._SEMIC_in_forControlExpression5187);
                                        DebugLocation(1481, 35);
                                        // ES3YUITest.g:1481:35: (ex3= expression )?
                                        int alt59 = 2;
                                        try
                                        {
                                            DebugEnterSubRule(59);
                                            try
                                            {
                                                DebugEnterDecision(59, false);
                                                int LA59_1 = input.LA(1);

                                                if ((LA59_1 == ADD || LA59_1 == DEC || LA59_1 == DELETE || LA59_1 == DecimalLiteral || LA59_1 == FALSE || LA59_1 == FUNCTION || LA59_1 == HexIntegerLiteral || LA59_1 == INC || LA59_1 == INV || LA59_1 == Identifier || (LA59_1 >= LBRACE && LA59_1 <= LBRACK) || LA59_1 == LPAREN || (LA59_1 >= NEW && LA59_1 <= NOT) || LA59_1 == NULL || LA59_1 == OctalIntegerLiteral || LA59_1 == RegularExpressionLiteral || LA59_1 == SUB || LA59_1 == StringLiteral || LA59_1 == THIS || LA59_1 == TRUE || LA59_1 == TYPEOF || LA59_1 == VOID))
                                                {
                                                    alt59 = 1;
                                                }
                                            }
                                            finally { DebugExitDecision(59); }
                                            switch (alt59)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:1481:35: ex3= expression
                                                    {
                                                        DebugLocation(1481, 35);
                                                        PushFollow(Follow._expression_in_forControlExpression5191);
                                                        ex3 = expression();
                                                        PopFollow();


                                                    }
                                                    break;

                                            }
                                        }
                                        finally { DebugExitSubRule(59); }


                                    }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(60); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("forControlExpression", 64);
                LeaveRule("forControlExpression", 64);
                LeaveRule_forControlExpression();
            }
            DebugLocation(1485, 1);
        }
        finally { DebugExitRule(GrammarFileName, "forControlExpression"); }
        return retval;

    }
    // $ANTLR end "forControlExpression"

    partial void EnterRule_forControlSemic();
    partial void LeaveRule_forControlSemic();
    // $ANTLR start "forControlSemic"
    // ES3YUITest.g:1487:1: forControlSemic : SEMIC (ex1= expression )? SEMIC (ex2= expression )? ;
    [GrammarRule("forControlSemic")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> forControlSemic()
    {
        EnterRule_forControlSemic();
        EnterRule("forControlSemic", 65);
        TraceIn("forControlSemic", 65);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> ex1 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);
        TemplateParserRuleReturnScope<StringTemplate, IToken> ex2 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "forControlSemic");
            DebugLocation(1487, 1);
            try
            {
                // ES3YUITest.g:1488:2: ( SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
                DebugEnterAlt(1);
                // ES3YUITest.g:1488:4: SEMIC (ex1= expression )? SEMIC (ex2= expression )?
                {
                    DebugLocation(1488, 4);
                    Match(input, SEMIC, Follow._SEMIC_in_forControlSemic5214);
                    DebugLocation(1488, 13);
                    // ES3YUITest.g:1488:13: (ex1= expression )?
                    int alt61 = 2;
                    try
                    {
                        DebugEnterSubRule(61);
                        try
                        {
                            DebugEnterDecision(61, false);
                            int LA61_1 = input.LA(1);

                            if ((LA61_1 == ADD || LA61_1 == DEC || LA61_1 == DELETE || LA61_1 == DecimalLiteral || LA61_1 == FALSE || LA61_1 == FUNCTION || LA61_1 == HexIntegerLiteral || LA61_1 == INC || LA61_1 == INV || LA61_1 == Identifier || (LA61_1 >= LBRACE && LA61_1 <= LBRACK) || LA61_1 == LPAREN || (LA61_1 >= NEW && LA61_1 <= NOT) || LA61_1 == NULL || LA61_1 == OctalIntegerLiteral || LA61_1 == RegularExpressionLiteral || LA61_1 == SUB || LA61_1 == StringLiteral || LA61_1 == THIS || LA61_1 == TRUE || LA61_1 == TYPEOF || LA61_1 == VOID))
                            {
                                alt61 = 1;
                            }
                        }
                        finally { DebugExitDecision(61); }
                        switch (alt61)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1488:13: ex1= expression
                                {
                                    DebugLocation(1488, 13);
                                    PushFollow(Follow._expression_in_forControlSemic5218);
                                    ex1 = expression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(61); }

                    DebugLocation(1488, 26);
                    Match(input, SEMIC, Follow._SEMIC_in_forControlSemic5221);
                    DebugLocation(1488, 35);
                    // ES3YUITest.g:1488:35: (ex2= expression )?
                    int alt62 = 2;
                    try
                    {
                        DebugEnterSubRule(62);
                        try
                        {
                            DebugEnterDecision(62, false);
                            int LA62_1 = input.LA(1);

                            if ((LA62_1 == ADD || LA62_1 == DEC || LA62_1 == DELETE || LA62_1 == DecimalLiteral || LA62_1 == FALSE || LA62_1 == FUNCTION || LA62_1 == HexIntegerLiteral || LA62_1 == INC || LA62_1 == INV || LA62_1 == Identifier || (LA62_1 >= LBRACE && LA62_1 <= LBRACK) || LA62_1 == LPAREN || (LA62_1 >= NEW && LA62_1 <= NOT) || LA62_1 == NULL || LA62_1 == OctalIntegerLiteral || LA62_1 == RegularExpressionLiteral || LA62_1 == SUB || LA62_1 == StringLiteral || LA62_1 == THIS || LA62_1 == TRUE || LA62_1 == TYPEOF || LA62_1 == VOID))
                            {
                                alt62 = 1;
                            }
                        }
                        finally { DebugExitDecision(62); }
                        switch (alt62)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1488:35: ex2= expression
                                {
                                    DebugLocation(1488, 35);
                                    PushFollow(Follow._expression_in_forControlSemic5225);
                                    ex2 = expression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(62); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("forControlSemic", 65);
                LeaveRule("forControlSemic", 65);
                LeaveRule_forControlSemic();
            }
            DebugLocation(1490, 1);
        }
        finally { DebugExitRule(GrammarFileName, "forControlSemic"); }
        return retval;

    }
    // $ANTLR end "forControlSemic"

    partial void EnterRule_continueStatement();
    partial void LeaveRule_continueStatement();
    // $ANTLR start "continueStatement"
    // ES3YUITest.g:1501:1: continueStatement : CONTINUE ( Identifier )? semic ;
    [GrammarRule("continueStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> continueStatement()
    {
        EnterRule_continueStatement();
        EnterRule("continueStatement", 66);
        TraceIn("continueStatement", 66);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "continueStatement");
            DebugLocation(1501, 1);
            try
            {
                // ES3YUITest.g:1502:2: ( CONTINUE ( Identifier )? semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1502:4: CONTINUE ( Identifier )? semic
                {
                    DebugLocation(1502, 4);
                    Match(input, CONTINUE, Follow._CONTINUE_in_continueStatement5246);
                    DebugLocation(1502, 13);
                    if (input.LA(1) == Identifier) PromoteEOL(null);
                    DebugLocation(1502, 66);
                    // ES3YUITest.g:1502:66: ( Identifier )?
                    int alt63 = 2;
                    try
                    {
                        DebugEnterSubRule(63);
                        try
                        {
                            DebugEnterDecision(63, false);
                            int LA63_1 = input.LA(1);

                            if ((LA63_1 == Identifier))
                            {
                                alt63 = 1;
                            }
                        }
                        finally { DebugExitDecision(63); }
                        switch (alt63)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1502:66: Identifier
                                {
                                    DebugLocation(1502, 66);
                                    Match(input, Identifier, Follow._Identifier_in_continueStatement5250);

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(63); }

                    DebugLocation(1502, 78);
                    PushFollow(Follow._semic_in_continueStatement5253);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("continueStatement", 66);
                LeaveRule("continueStatement", 66);
                LeaveRule_continueStatement();
            }
            DebugLocation(1503, 1);
        }
        finally { DebugExitRule(GrammarFileName, "continueStatement"); }
        return retval;

    }
    // $ANTLR end "continueStatement"

    partial void EnterRule_breakStatement();
    partial void LeaveRule_breakStatement();
    // $ANTLR start "breakStatement"
    // ES3YUITest.g:1514:1: breakStatement : BREAK ( Identifier )? semic ;
    [GrammarRule("breakStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> breakStatement()
    {
        EnterRule_breakStatement();
        EnterRule("breakStatement", 67);
        TraceIn("breakStatement", 67);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "breakStatement");
            DebugLocation(1514, 1);
            try
            {
                // ES3YUITest.g:1515:2: ( BREAK ( Identifier )? semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1515:4: BREAK ( Identifier )? semic
                {
                    DebugLocation(1515, 4);
                    Match(input, BREAK, Follow._BREAK_in_breakStatement5271);
                    DebugLocation(1515, 10);
                    if (input.LA(1) == Identifier) PromoteEOL(null);
                    DebugLocation(1515, 63);
                    // ES3YUITest.g:1515:63: ( Identifier )?
                    int alt64 = 2;
                    try
                    {
                        DebugEnterSubRule(64);
                        try
                        {
                            DebugEnterDecision(64, false);
                            int LA64_1 = input.LA(1);

                            if ((LA64_1 == Identifier))
                            {
                                alt64 = 1;
                            }
                        }
                        finally { DebugExitDecision(64); }
                        switch (alt64)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1515:63: Identifier
                                {
                                    DebugLocation(1515, 63);
                                    Match(input, Identifier, Follow._Identifier_in_breakStatement5275);

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(64); }

                    DebugLocation(1515, 75);
                    PushFollow(Follow._semic_in_breakStatement5278);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("breakStatement", 67);
                LeaveRule("breakStatement", 67);
                LeaveRule_breakStatement();
            }
            DebugLocation(1516, 1);
        }
        finally { DebugExitRule(GrammarFileName, "breakStatement"); }
        return retval;

    }
    // $ANTLR end "breakStatement"

    partial void EnterRule_returnStatement();
    partial void LeaveRule_returnStatement();
    // $ANTLR start "returnStatement"
    // ES3YUITest.g:1535:1: returnStatement : RETURN ( expression )? semic ;
    [GrammarRule("returnStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> returnStatement()
    {
        EnterRule_returnStatement();
        EnterRule("returnStatement", 68);
        TraceIn("returnStatement", 68);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "returnStatement");
            DebugLocation(1535, 1);
            try
            {
                // ES3YUITest.g:1536:2: ( RETURN ( expression )? semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1536:4: RETURN ( expression )? semic
                {
                    DebugLocation(1536, 4);
                    Match(input, RETURN, Follow._RETURN_in_returnStatement5296);
                    DebugLocation(1536, 11);
                    PromoteEOL(null);
                    DebugLocation(1536, 33);
                    // ES3YUITest.g:1536:33: ( expression )?
                    int alt65 = 2;
                    try
                    {
                        DebugEnterSubRule(65);
                        try
                        {
                            DebugEnterDecision(65, false);
                            int LA65_1 = input.LA(1);

                            if ((LA65_1 == ADD || LA65_1 == DEC || LA65_1 == DELETE || LA65_1 == DecimalLiteral || LA65_1 == FALSE || LA65_1 == FUNCTION || LA65_1 == HexIntegerLiteral || LA65_1 == INC || LA65_1 == INV || LA65_1 == Identifier || (LA65_1 >= LBRACE && LA65_1 <= LBRACK) || LA65_1 == LPAREN || (LA65_1 >= NEW && LA65_1 <= NOT) || LA65_1 == NULL || LA65_1 == OctalIntegerLiteral || LA65_1 == RegularExpressionLiteral || LA65_1 == SUB || LA65_1 == StringLiteral || LA65_1 == THIS || LA65_1 == TRUE || LA65_1 == TYPEOF || LA65_1 == VOID))
                            {
                                alt65 = 1;
                            }
                        }
                        finally { DebugExitDecision(65); }
                        switch (alt65)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1536:33: expression
                                {
                                    DebugLocation(1536, 33);
                                    PushFollow(Follow._expression_in_returnStatement5300);
                                    expression();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(65); }

                    DebugLocation(1536, 45);
                    PushFollow(Follow._semic_in_returnStatement5303);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("returnStatement", 68);
                LeaveRule("returnStatement", 68);
                LeaveRule_returnStatement();
            }
            DebugLocation(1537, 1);
        }
        finally { DebugExitRule(GrammarFileName, "returnStatement"); }
        return retval;

    }
    // $ANTLR end "returnStatement"

    partial void EnterRule_withStatement();
    partial void LeaveRule_withStatement();
    // $ANTLR start "withStatement"
    // ES3YUITest.g:1543:1: withStatement : WITH LPAREN expression RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\";
    [GrammarRule("withStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> withStatement()
    {
        EnterRule_withStatement();
        EnterRule("withStatement", 69);
        TraceIn("withStatement", 69);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        TemplateParserRuleReturnScope<StringTemplate, IToken> statement10 = default(TemplateParserRuleReturnScope<StringTemplate, IToken>);

        try
        {
            DebugEnterRule(GrammarFileName, "withStatement");
            DebugLocation(1543, 1);
            try
            {
                // ES3YUITest.g:1544:2: ( WITH LPAREN expression RPAREN statement -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\")
                DebugEnterAlt(1);
                // ES3YUITest.g:1544:4: WITH LPAREN expression RPAREN statement
                {
                    DebugLocation(1544, 4);
                    Match(input, WITH, Follow._WITH_in_withStatement5319);
                    DebugLocation(1544, 9);
                    Match(input, LPAREN, Follow._LPAREN_in_withStatement5321);
                    DebugLocation(1544, 16);
                    PushFollow(Follow._expression_in_withStatement5323);
                    expression();
                    PopFollow();

                    DebugLocation(1544, 27);
                    Match(input, RPAREN, Follow._RPAREN_in_withStatement5325);
                    DebugLocation(1544, 34);
                    PushFollow(Follow._statement_in_withStatement5327);
                    statement10 = statement();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1545:2: -> template(pre=input.ToString($start.TokenIndex, $statement.start.TokenIndex - 1)stmt=WrapInBraces($statement.start, $statement.stop, input)) \"<pre><stmt>\"
                    {
                        retval.Template = new StringTemplate(TemplateGroup, "<pre><stmt>",
                        new Dictionary<string, object>() { { "pre", input.ToString(retval.Start.TokenIndex, (statement10 != null ? ((IToken)statement10.Start) : default(IToken)).TokenIndex - 1) }, { "stmt", WrapInBraces((statement10 != null ? ((IToken)statement10.Start) : default(IToken)), (statement10 != null ? ((IToken)statement10.Stop) : default(IToken)), input) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("withStatement", 69);
                LeaveRule("withStatement", 69);
                LeaveRule_withStatement();
            }
            DebugLocation(1548, 1);
        }
        finally { DebugExitRule(GrammarFileName, "withStatement"); }
        return retval;

    }
    // $ANTLR end "withStatement"

    partial void EnterRule_switchStatement();
    partial void LeaveRule_switchStatement();
    // $ANTLR start "switchStatement"
    // ES3YUITest.g:1554:1: switchStatement : SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE ;
    [GrammarRule("switchStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> switchStatement()
    {
        EnterRule_switchStatement();
        EnterRule("switchStatement", 70);
        TraceIn("switchStatement", 70);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);


        int defaultClauseCount = 0;

        try
        {
            DebugEnterRule(GrammarFileName, "switchStatement");
            DebugLocation(1554, 1);
            try
            {
                // ES3YUITest.g:1559:2: ( SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE )
                DebugEnterAlt(1);
                // ES3YUITest.g:1559:4: SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE
                {
                    DebugLocation(1559, 4);
                    Match(input, SWITCH, Follow._SWITCH_in_switchStatement5396);
                    DebugLocation(1559, 11);
                    Match(input, LPAREN, Follow._LPAREN_in_switchStatement5398);
                    DebugLocation(1559, 18);
                    PushFollow(Follow._expression_in_switchStatement5400);
                    expression();
                    PopFollow();

                    DebugLocation(1559, 29);
                    Match(input, RPAREN, Follow._RPAREN_in_switchStatement5402);
                    DebugLocation(1559, 36);
                    Match(input, LBRACE, Follow._LBRACE_in_switchStatement5404);
                    DebugLocation(1559, 43);
                    // ES3YUITest.g:1559:43: ({...}? => defaultClause | caseClause )*
                    try
                    {
                        DebugEnterSubRule(66);
                        while (true)
                        {
                            int alt66 = 3;
                            try
                            {
                                DebugEnterDecision(66, false);
                                int LA66_1 = input.LA(1);

                                if ((LA66_1 == DEFAULT) && ((defaultClauseCount == 0)))
                                {
                                    alt66 = 1;
                                }
                                else if ((LA66_1 == CASE))
                                {
                                    alt66 = 2;
                                }


                            }
                            finally { DebugExitDecision(66); }
                            switch (alt66)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1559:45: {...}? => defaultClause
                                    {
                                        DebugLocation(1559, 45);
                                        if (!((defaultClauseCount == 0)))
                                        {
                                            throw new FailedPredicateException(input, "switchStatement", " defaultClauseCount == 0 ");
                                        }
                                        DebugLocation(1559, 76);
                                        PushFollow(Follow._defaultClause_in_switchStatement5411);
                                        defaultClause();
                                        PopFollow();

                                        DebugLocation(1559, 90);
                                        defaultClauseCount++;

                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // ES3YUITest.g:1559:118: caseClause
                                    {
                                        DebugLocation(1559, 118);
                                        PushFollow(Follow._caseClause_in_switchStatement5417);
                                        caseClause();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop66;
                            }
                        }

                    loop66:
                        ;

                    }
                    finally { DebugExitSubRule(66); }

                    DebugLocation(1559, 132);
                    Match(input, RBRACE, Follow._RBRACE_in_switchStatement5422);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("switchStatement", 70);
                LeaveRule("switchStatement", 70);
                LeaveRule_switchStatement();
            }
            DebugLocation(1561, 1);
        }
        finally { DebugExitRule(GrammarFileName, "switchStatement"); }
        return retval;

    }
    // $ANTLR end "switchStatement"

    partial void EnterRule_caseClause();
    partial void LeaveRule_caseClause();
    // $ANTLR start "caseClause"
    // ES3YUITest.g:1563:1: caseClause : CASE expression COLON ( statement )* ;
    [GrammarRule("caseClause")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> caseClause()
    {
        EnterRule_caseClause();
        EnterRule("caseClause", 71);
        TraceIn("caseClause", 71);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "caseClause");
            DebugLocation(1563, 1);
            try
            {
                // ES3YUITest.g:1564:2: ( CASE expression COLON ( statement )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1564:4: CASE expression COLON ( statement )*
                {
                    DebugLocation(1564, 4);
                    Match(input, CASE, Follow._CASE_in_caseClause5435);
                    DebugLocation(1564, 9);
                    PushFollow(Follow._expression_in_caseClause5437);
                    expression();
                    PopFollow();

                    DebugLocation(1564, 20);
                    Match(input, COLON, Follow._COLON_in_caseClause5439);
                    DebugLocation(1564, 26);
                    // ES3YUITest.g:1564:26: ( statement )*
                    try
                    {
                        DebugEnterSubRule(67);
                        while (true)
                        {
                            int alt67 = 2;
                            try
                            {
                                DebugEnterDecision(67, false);
                                int LA67_1 = input.LA(1);

                                if ((LA67_1 == ADD || LA67_1 == BREAK || LA67_1 == CONTINUE || LA67_1 == DEC || LA67_1 == DELETE || LA67_1 == DO || LA67_1 == DecimalLiteral || LA67_1 == FALSE || LA67_1 == FOR || LA67_1 == FUNCTION || (LA67_1 >= HexIntegerLiteral && LA67_1 <= IF) || LA67_1 == INC || LA67_1 == INV || LA67_1 == Identifier || (LA67_1 >= LBRACE && LA67_1 <= LBRACK) || LA67_1 == LPAREN || (LA67_1 >= NEW && LA67_1 <= NOT) || LA67_1 == NULL || LA67_1 == OctalIntegerLiteral || LA67_1 == RETURN || LA67_1 == RegularExpressionLiteral || LA67_1 == SEMIC || LA67_1 == SUB || LA67_1 == SWITCH || LA67_1 == StringLiteral || (LA67_1 >= THIS && LA67_1 <= THROW) || (LA67_1 >= TRUE && LA67_1 <= TYPEOF) || (LA67_1 >= VAR && LA67_1 <= VOID) || (LA67_1 >= WHILE && LA67_1 <= WITH)))
                                {
                                    alt67 = 1;
                                }


                            }
                            finally { DebugExitDecision(67); }
                            switch (alt67)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1564:26: statement
                                    {
                                        DebugLocation(1564, 26);
                                        PushFollow(Follow._statement_in_caseClause5441);
                                        statement();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop67;
                            }
                        }

                    loop67:
                        ;

                    }
                    finally { DebugExitSubRule(67); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("caseClause", 71);
                LeaveRule("caseClause", 71);
                LeaveRule_caseClause();
            }
            DebugLocation(1565, 1);
        }
        finally { DebugExitRule(GrammarFileName, "caseClause"); }
        return retval;

    }
    // $ANTLR end "caseClause"

    partial void EnterRule_defaultClause();
    partial void LeaveRule_defaultClause();
    // $ANTLR start "defaultClause"
    // ES3YUITest.g:1567:1: defaultClause : DEFAULT COLON ( statement )* ;
    [GrammarRule("defaultClause")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> defaultClause()
    {
        EnterRule_defaultClause();
        EnterRule("defaultClause", 72);
        TraceIn("defaultClause", 72);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "defaultClause");
            DebugLocation(1567, 1);
            try
            {
                // ES3YUITest.g:1568:2: ( DEFAULT COLON ( statement )* )
                DebugEnterAlt(1);
                // ES3YUITest.g:1568:4: DEFAULT COLON ( statement )*
                {
                    DebugLocation(1568, 4);
                    Match(input, DEFAULT, Follow._DEFAULT_in_defaultClause5454);
                    DebugLocation(1568, 12);
                    Match(input, COLON, Follow._COLON_in_defaultClause5456);
                    DebugLocation(1568, 18);
                    // ES3YUITest.g:1568:18: ( statement )*
                    try
                    {
                        DebugEnterSubRule(68);
                        while (true)
                        {
                            int alt68 = 2;
                            try
                            {
                                DebugEnterDecision(68, false);
                                int LA68_1 = input.LA(1);

                                if ((LA68_1 == ADD || LA68_1 == BREAK || LA68_1 == CONTINUE || LA68_1 == DEC || LA68_1 == DELETE || LA68_1 == DO || LA68_1 == DecimalLiteral || LA68_1 == FALSE || LA68_1 == FOR || LA68_1 == FUNCTION || (LA68_1 >= HexIntegerLiteral && LA68_1 <= IF) || LA68_1 == INC || LA68_1 == INV || LA68_1 == Identifier || (LA68_1 >= LBRACE && LA68_1 <= LBRACK) || LA68_1 == LPAREN || (LA68_1 >= NEW && LA68_1 <= NOT) || LA68_1 == NULL || LA68_1 == OctalIntegerLiteral || LA68_1 == RETURN || LA68_1 == RegularExpressionLiteral || LA68_1 == SEMIC || LA68_1 == SUB || LA68_1 == SWITCH || LA68_1 == StringLiteral || (LA68_1 >= THIS && LA68_1 <= THROW) || (LA68_1 >= TRUE && LA68_1 <= TYPEOF) || (LA68_1 >= VAR && LA68_1 <= VOID) || (LA68_1 >= WHILE && LA68_1 <= WITH)))
                                {
                                    alt68 = 1;
                                }


                            }
                            finally { DebugExitDecision(68); }
                            switch (alt68)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1568:18: statement
                                    {
                                        DebugLocation(1568, 18);
                                        PushFollow(Follow._statement_in_defaultClause5458);
                                        statement();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop68;
                            }
                        }

                    loop68:
                        ;

                    }
                    finally { DebugExitSubRule(68); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("defaultClause", 72);
                LeaveRule("defaultClause", 72);
                LeaveRule_defaultClause();
            }
            DebugLocation(1569, 1);
        }
        finally { DebugExitRule(GrammarFileName, "defaultClause"); }
        return retval;

    }
    // $ANTLR end "defaultClause"

    partial void EnterRule_labelledStatement();
    partial void LeaveRule_labelledStatement();
    // $ANTLR start "labelledStatement"
    // ES3YUITest.g:1575:1: labelledStatement : Identifier COLON statement ;
    [GrammarRule("labelledStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> labelledStatement()
    {
        EnterRule_labelledStatement();
        EnterRule("labelledStatement", 73);
        TraceIn("labelledStatement", 73);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "labelledStatement");
            DebugLocation(1575, 1);
            try
            {
                // ES3YUITest.g:1576:2: ( Identifier COLON statement )
                DebugEnterAlt(1);
                // ES3YUITest.g:1576:4: Identifier COLON statement
                {
                    DebugLocation(1576, 4);
                    Match(input, Identifier, Follow._Identifier_in_labelledStatement5475);
                    DebugLocation(1576, 15);
                    Match(input, COLON, Follow._COLON_in_labelledStatement5477);
                    DebugLocation(1576, 21);
                    PushFollow(Follow._statement_in_labelledStatement5479);
                    statement();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("labelledStatement", 73);
                LeaveRule("labelledStatement", 73);
                LeaveRule_labelledStatement();
            }
            DebugLocation(1578, 1);
        }
        finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
        return retval;

    }
    // $ANTLR end "labelledStatement"

    partial void EnterRule_throwStatement();
    partial void LeaveRule_throwStatement();
    // $ANTLR start "throwStatement"
    // ES3YUITest.g:1599:1: throwStatement : THROW expression semic ;
    [GrammarRule("throwStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> throwStatement()
    {
        EnterRule_throwStatement();
        EnterRule("throwStatement", 74);
        TraceIn("throwStatement", 74);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "throwStatement");
            DebugLocation(1599, 1);
            try
            {
                // ES3YUITest.g:1600:2: ( THROW expression semic )
                DebugEnterAlt(1);
                // ES3YUITest.g:1600:4: THROW expression semic
                {
                    DebugLocation(1600, 4);
                    Match(input, THROW, Follow._THROW_in_throwStatement5499);
                    DebugLocation(1600, 10);
                    PromoteEOL(null);
                    DebugLocation(1600, 32);
                    PushFollow(Follow._expression_in_throwStatement5503);
                    expression();
                    PopFollow();

                    DebugLocation(1600, 43);
                    PushFollow(Follow._semic_in_throwStatement5505);
                    semic();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("throwStatement", 74);
                LeaveRule("throwStatement", 74);
                LeaveRule_throwStatement();
            }
            DebugLocation(1601, 1);
        }
        finally { DebugExitRule(GrammarFileName, "throwStatement"); }
        return retval;

    }
    // $ANTLR end "throwStatement"

    partial void EnterRule_tryStatement();
    partial void LeaveRule_tryStatement();
    // $ANTLR start "tryStatement"
    // ES3YUITest.g:1607:1: tryStatement : TRY block ( catchClause ( finallyClause )? | finallyClause ) ;
    [GrammarRule("tryStatement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> tryStatement()
    {
        EnterRule_tryStatement();
        EnterRule("tryStatement", 75);
        TraceIn("tryStatement", 75);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "tryStatement");
            DebugLocation(1607, 1);
            try
            {
                // ES3YUITest.g:1608:2: ( TRY block ( catchClause ( finallyClause )? | finallyClause ) )
                DebugEnterAlt(1);
                // ES3YUITest.g:1608:4: TRY block ( catchClause ( finallyClause )? | finallyClause )
                {
                    DebugLocation(1608, 4);
                    Match(input, TRY, Follow._TRY_in_tryStatement5521);
                    DebugLocation(1608, 8);
                    PushFollow(Follow._block_in_tryStatement5523);
                    block();
                    PopFollow();

                    DebugLocation(1608, 14);
                    // ES3YUITest.g:1608:14: ( catchClause ( finallyClause )? | finallyClause )
                    int alt70 = 2;
                    try
                    {
                        DebugEnterSubRule(70);
                        try
                        {
                            DebugEnterDecision(70, false);
                            int LA70_1 = input.LA(1);

                            if ((LA70_1 == CATCH))
                            {
                                alt70 = 1;
                            }
                            else if ((LA70_1 == FINALLY))
                            {
                                alt70 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(70); }
                        switch (alt70)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1608:16: catchClause ( finallyClause )?
                                {
                                    DebugLocation(1608, 16);
                                    PushFollow(Follow._catchClause_in_tryStatement5527);
                                    catchClause();
                                    PopFollow();

                                    DebugLocation(1608, 28);
                                    // ES3YUITest.g:1608:28: ( finallyClause )?
                                    int alt69 = 2;
                                    try
                                    {
                                        DebugEnterSubRule(69);
                                        try
                                        {
                                            DebugEnterDecision(69, false);
                                            int LA69_1 = input.LA(1);

                                            if ((LA69_1 == FINALLY))
                                            {
                                                alt69 = 1;
                                            }
                                        }
                                        finally { DebugExitDecision(69); }
                                        switch (alt69)
                                        {
                                            case 1:
                                                DebugEnterAlt(1);
                                                // ES3YUITest.g:1608:28: finallyClause
                                                {
                                                    DebugLocation(1608, 28);
                                                    PushFollow(Follow._finallyClause_in_tryStatement5529);
                                                    finallyClause();
                                                    PopFollow();


                                                }
                                                break;

                                        }
                                    }
                                    finally { DebugExitSubRule(69); }


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // ES3YUITest.g:1608:45: finallyClause
                                {
                                    DebugLocation(1608, 45);
                                    PushFollow(Follow._finallyClause_in_tryStatement5534);
                                    finallyClause();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(70); }


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("tryStatement", 75);
                LeaveRule("tryStatement", 75);
                LeaveRule_tryStatement();
            }
            DebugLocation(1609, 1);
        }
        finally { DebugExitRule(GrammarFileName, "tryStatement"); }
        return retval;

    }
    // $ANTLR end "tryStatement"

    partial void EnterRule_catchClause();
    partial void LeaveRule_catchClause();
    // $ANTLR start "catchClause"
    // ES3YUITest.g:1611:1: catchClause : CATCH LPAREN Identifier RPAREN block ;
    [GrammarRule("catchClause")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> catchClause()
    {
        EnterRule_catchClause();
        EnterRule("catchClause", 76);
        TraceIn("catchClause", 76);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "catchClause");
            DebugLocation(1611, 1);
            try
            {
                // ES3YUITest.g:1612:2: ( CATCH LPAREN Identifier RPAREN block )
                DebugEnterAlt(1);
                // ES3YUITest.g:1612:4: CATCH LPAREN Identifier RPAREN block
                {
                    DebugLocation(1612, 4);
                    Match(input, CATCH, Follow._CATCH_in_catchClause5548);
                    DebugLocation(1612, 10);
                    Match(input, LPAREN, Follow._LPAREN_in_catchClause5550);
                    DebugLocation(1612, 17);
                    Match(input, Identifier, Follow._Identifier_in_catchClause5552);
                    DebugLocation(1612, 28);
                    Match(input, RPAREN, Follow._RPAREN_in_catchClause5554);
                    DebugLocation(1612, 35);
                    PushFollow(Follow._block_in_catchClause5556);
                    block();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("catchClause", 76);
                LeaveRule("catchClause", 76);
                LeaveRule_catchClause();
            }
            DebugLocation(1613, 1);
        }
        finally { DebugExitRule(GrammarFileName, "catchClause"); }
        return retval;

    }
    // $ANTLR end "catchClause"

    partial void EnterRule_finallyClause();
    partial void LeaveRule_finallyClause();
    // $ANTLR start "finallyClause"
    // ES3YUITest.g:1615:1: finallyClause : FINALLY block ;
    [GrammarRule("finallyClause")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> finallyClause()
    {
        EnterRule_finallyClause();
        EnterRule("finallyClause", 77);
        TraceIn("finallyClause", 77);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "finallyClause");
            DebugLocation(1615, 1);
            try
            {
                // ES3YUITest.g:1616:2: ( FINALLY block )
                DebugEnterAlt(1);
                // ES3YUITest.g:1616:4: FINALLY block
                {
                    DebugLocation(1616, 4);
                    Match(input, FINALLY, Follow._FINALLY_in_finallyClause5568);
                    DebugLocation(1616, 12);
                    PushFollow(Follow._block_in_finallyClause5570);
                    block();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("finallyClause", 77);
                LeaveRule("finallyClause", 77);
                LeaveRule_finallyClause();
            }
            DebugLocation(1617, 1);
        }
        finally { DebugExitRule(GrammarFileName, "finallyClause"); }
        return retval;

    }
    // $ANTLR end "finallyClause"

    protected sealed partial class functionDeclaration_scope
    {
        public string funcName;
        public int funcLine;

        public functionDeclaration_scope(ES3YUITestParser grammar) { OnCreated(grammar); }
        partial void OnCreated(ES3YUITestParser grammar);
    }
    partial void functionDeclaration_scopeInit(functionDeclaration_scope scope);
    partial void functionDeclaration_scopeAfter(functionDeclaration_scope scope);
    protected readonly ListStack<functionDeclaration_scope> functionDeclaration_stack = new ListStack<functionDeclaration_scope>();

    partial void EnterRule_functionDeclaration();
    partial void LeaveRule_functionDeclaration();
    // $ANTLR start "functionDeclaration"
    // ES3YUITest.g:1630:1: functionDeclaration : FUNCTION name= Identifier formalParameterList functionDeclarationBody -> {instrument}? cover_line(src=$program::namecode=$textline=$start.Line) -> ignore(code=$text);
    [GrammarRule("functionDeclaration")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionDeclaration()
    {
        EnterRule_functionDeclaration();
        EnterRule("functionDeclaration", 78);
        TraceIn("functionDeclaration", 78);
        functionDeclaration_stack.Push(new functionDeclaration_scope(this)); functionDeclaration_scopeInit(functionDeclaration_stack.Peek());
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken name = default(IToken);



        bool instrument = false;
        if (retval.Start.Line > program_stack.Peek().stopLine)
        {
            program_stack.Peek().executableLines.Add(retval.Start.Line);
            program_stack.Peek().stopLine = retval.Start.Line;
            instrument = true;
        }
        functionDeclaration_stack.Peek().funcLine = retval.Start.Line;

        try
        {
            DebugEnterRule(GrammarFileName, "functionDeclaration");
            DebugLocation(1630, 1);
            try
            {
                // ES3YUITest.g:1652:2: ( FUNCTION name= Identifier formalParameterList functionDeclarationBody -> {instrument}? cover_line(src=$program::namecode=$textline=$start.Line) -> ignore(code=$text))
                DebugEnterAlt(1);
                // ES3YUITest.g:1652:4: FUNCTION name= Identifier formalParameterList functionDeclarationBody
                {
                    DebugLocation(1652, 4);
                    Match(input, FUNCTION, Follow._FUNCTION_in_functionDeclaration5606);
                    DebugLocation(1652, 17);
                    name = (IToken)Match(input, Identifier, Follow._Identifier_in_functionDeclaration5610);
                    DebugLocation(1652, 29);
                    functionDeclaration_stack.Peek().funcName = (name != null ? name.Text : default(string));
                    DebugLocation(1652, 80);
                    PushFollow(Follow._formalParameterList_in_functionDeclaration5614);
                    formalParameterList();
                    PopFollow();

                    DebugLocation(1652, 100);
                    PushFollow(Follow._functionDeclarationBody_in_functionDeclaration5616);
                    functionDeclarationBody();
                    PopFollow();


                    // TEMPLATE REWRITE
                    // 1653:4: -> {instrument}? cover_line(src=$program::namecode=$textline=$start.Line)
                    if (instrument)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_line",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "line", retval.Start.Line } }
                    );
                    }

                    else // 1654:4: -> ignore(code=$text)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("ignore",
                        new Dictionary<string, object>() { { "code", input.ToString(retval.Start, input.LT(-1)) } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);


                program_stack.Peek().functions.Add("\"" + functionDeclaration_stack.Peek().funcName + ":" + retval.Start.Line + "\"");
                if (Verbose)
                {
                    Console.WriteLine("\n[INFO] Instrumenting function " + functionDeclaration_stack.Peek().funcName + " on line " + retval.Start.Line);
                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionDeclaration", 78);
                LeaveRule("functionDeclaration", 78);
                LeaveRule_functionDeclaration();
                functionDeclaration_scopeAfter(functionDeclaration_stack.Peek()); functionDeclaration_stack.Pop();
            }
            DebugLocation(1655, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
        return retval;

    }
    // $ANTLR end "functionDeclaration"

    protected sealed partial class functionExpression_scope
    {
        public string funcName;
        public int funcLine;

        public functionExpression_scope(ES3YUITestParser grammar) { OnCreated(grammar); }
        partial void OnCreated(ES3YUITestParser grammar);
    }
    partial void functionExpression_scopeInit(functionExpression_scope scope);
    partial void functionExpression_scopeAfter(functionExpression_scope scope);
    protected readonly ListStack<functionExpression_scope> functionExpression_stack = new ListStack<functionExpression_scope>();

    partial void EnterRule_functionExpression();
    partial void LeaveRule_functionExpression();
    // $ANTLR start "functionExpression"
    // ES3YUITest.g:1657:1: functionExpression : FUNCTION ( Identifier )? formalParameterList functionExpressionBody ;
    [GrammarRule("functionExpression")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionExpression()
    {
        EnterRule_functionExpression();
        EnterRule("functionExpression", 79);
        TraceIn("functionExpression", 79);
        functionExpression_stack.Push(new functionExpression_scope(this)); functionExpression_scopeInit(functionExpression_stack.Peek());
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);


        functionExpression_stack.Peek().funcLine = retval.Start.Line;

        /*
         * The function expression might have an identifier, and if so, use that as
         * the name.
         *
         * This might be a function that's a method in an object literal. If so,
         * the previous token will be a colon and the one prior to that will be the
         * identifier.
         *
         * Function may also be assigned to a variable. In that case, the previous
         * token will be the equals sign (=) and the token prior to that is the
         * variable/property.
         *
         * Even after all that, the function expression might have a declared name
         * as if it were a function declaration. If so, the declared function name
         * takes precendence over any object literal or variable assignment.
         */
        int lastTT = input.LA(-1);   //look for = or :
        int nextTT = input.LA(2);    //look for an identifer

        if (nextTT == Identifier)
        {
            functionExpression_stack.Peek().funcName = input.LT(2).Text;
        }
        else if (lastTT == COLON || lastTT == ASSIGN)
        {
            functionExpression_stack.Peek().funcName = input.LT(-2).Text.Replace("\"", "\\\"").Replace("'", "\\'");

            //TODO: Continue walking back in case the identifier is object.name
            //right now, I end up just with name.
        }
        else
        {
            functionExpression_stack.Peek().funcName = "(anonymous " + (++program_stack.Peek().anonymousFunctionCount) + ")";
        }


        try
        {
            DebugEnterRule(GrammarFileName, "functionExpression");
            DebugLocation(1657, 1);
            try
            {
                // ES3YUITest.g:1696:2: ( FUNCTION ( Identifier )? formalParameterList functionExpressionBody )
                DebugEnterAlt(1);
                // ES3YUITest.g:1696:4: FUNCTION ( Identifier )? formalParameterList functionExpressionBody
                {
                    DebugLocation(1696, 4);
                    Match(input, FUNCTION, Follow._FUNCTION_in_functionExpression5671);
                    DebugLocation(1696, 13);
                    // ES3YUITest.g:1696:13: ( Identifier )?
                    int alt71 = 2;
                    try
                    {
                        DebugEnterSubRule(71);
                        try
                        {
                            DebugEnterDecision(71, false);
                            int LA71_1 = input.LA(1);

                            if ((LA71_1 == Identifier))
                            {
                                alt71 = 1;
                            }
                        }
                        finally { DebugExitDecision(71); }
                        switch (alt71)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1696:13: Identifier
                                {
                                    DebugLocation(1696, 13);
                                    Match(input, Identifier, Follow._Identifier_in_functionExpression5673);

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(71); }

                    DebugLocation(1696, 25);
                    PushFollow(Follow._formalParameterList_in_functionExpression5676);
                    formalParameterList();
                    PopFollow();

                    DebugLocation(1696, 45);
                    PushFollow(Follow._functionExpressionBody_in_functionExpression5678);
                    functionExpressionBody();
                    PopFollow();


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionExpression", 79);
                LeaveRule("functionExpression", 79);
                LeaveRule_functionExpression();
                functionExpression_scopeAfter(functionExpression_stack.Peek()); functionExpression_stack.Pop();
            }
            DebugLocation(1697, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionExpression"); }
        return retval;

    }
    // $ANTLR end "functionExpression"

    partial void EnterRule_formalParameterList();
    partial void LeaveRule_formalParameterList();
    // $ANTLR start "formalParameterList"
    // ES3YUITest.g:1699:1: formalParameterList : LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN ;
    [GrammarRule("formalParameterList")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> formalParameterList()
    {
        EnterRule_formalParameterList();
        EnterRule("formalParameterList", 80);
        TraceIn("formalParameterList", 80);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "formalParameterList");
            DebugLocation(1699, 1);
            try
            {
                // ES3YUITest.g:1700:2: ( LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN )
                DebugEnterAlt(1);
                // ES3YUITest.g:1700:4: LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN
                {
                    DebugLocation(1700, 4);
                    Match(input, LPAREN, Follow._LPAREN_in_formalParameterList5689);
                    DebugLocation(1700, 11);
                    // ES3YUITest.g:1700:11: ( Identifier ( COMMA Identifier )* )?
                    int alt73 = 2;
                    try
                    {
                        DebugEnterSubRule(73);
                        try
                        {
                            DebugEnterDecision(73, false);
                            int LA73_1 = input.LA(1);

                            if ((LA73_1 == Identifier))
                            {
                                alt73 = 1;
                            }
                        }
                        finally { DebugExitDecision(73); }
                        switch (alt73)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1700:13: Identifier ( COMMA Identifier )*
                                {
                                    DebugLocation(1700, 13);
                                    Match(input, Identifier, Follow._Identifier_in_formalParameterList5693);
                                    DebugLocation(1700, 24);
                                    // ES3YUITest.g:1700:24: ( COMMA Identifier )*
                                    try
                                    {
                                        DebugEnterSubRule(72);
                                        while (true)
                                        {
                                            int alt72 = 2;
                                            try
                                            {
                                                DebugEnterDecision(72, false);
                                                int LA72_1 = input.LA(1);

                                                if ((LA72_1 == COMMA))
                                                {
                                                    alt72 = 1;
                                                }


                                            }
                                            finally { DebugExitDecision(72); }
                                            switch (alt72)
                                            {
                                                case 1:
                                                    DebugEnterAlt(1);
                                                    // ES3YUITest.g:1700:26: COMMA Identifier
                                                    {
                                                        DebugLocation(1700, 26);
                                                        Match(input, COMMA, Follow._COMMA_in_formalParameterList5697);
                                                        DebugLocation(1700, 32);
                                                        Match(input, Identifier, Follow._Identifier_in_formalParameterList5699);

                                                    }
                                                    break;

                                                default:
                                                    goto loop72;
                                            }
                                        }

                                    loop72:
                                        ;

                                    }
                                    finally { DebugExitSubRule(72); }


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(73); }

                    DebugLocation(1700, 49);
                    Match(input, RPAREN, Follow._RPAREN_in_formalParameterList5707);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("formalParameterList", 80);
                LeaveRule("formalParameterList", 80);
                LeaveRule_formalParameterList();
            }
            DebugLocation(1701, 1);
        }
        finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
        return retval;

    }
    // $ANTLR end "formalParameterList"

    partial void EnterRule_functionDeclarationBody();
    partial void LeaveRule_functionDeclarationBody();
    // $ANTLR start "functionDeclarationBody"
    // ES3YUITest.g:1703:1: functionDeclarationBody : lb= LBRACE ( functionDeclarationBodyWithoutBraces )? RBRACE ;
    [GrammarRule("functionDeclarationBody")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionDeclarationBody()
    {
        EnterRule_functionDeclarationBody();
        EnterRule("functionDeclarationBody", 81);
        TraceIn("functionDeclarationBody", 81);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lb = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "functionDeclarationBody");
            DebugLocation(1703, 1);
            try
            {
                // ES3YUITest.g:1704:2: (lb= LBRACE ( functionDeclarationBodyWithoutBraces )? RBRACE )
                DebugEnterAlt(1);
                // ES3YUITest.g:1704:4: lb= LBRACE ( functionDeclarationBodyWithoutBraces )? RBRACE
                {
                    DebugLocation(1704, 6);
                    lb = (IToken)Match(input, LBRACE, Follow._LBRACE_in_functionDeclarationBody5720);
                    DebugLocation(1704, 14);
                    // ES3YUITest.g:1704:14: ( functionDeclarationBodyWithoutBraces )?
                    int alt74 = 2;
                    try
                    {
                        DebugEnterSubRule(74);
                        try
                        {
                            DebugEnterDecision(74, false);
                            int LA74_1 = input.LA(1);

                            if ((LA74_1 == ADD || LA74_1 == BREAK || LA74_1 == CONTINUE || LA74_1 == DEC || LA74_1 == DELETE || LA74_1 == DO || LA74_1 == DecimalLiteral || LA74_1 == FALSE || LA74_1 == FOR || LA74_1 == FUNCTION || (LA74_1 >= HexIntegerLiteral && LA74_1 <= IF) || LA74_1 == INC || LA74_1 == INV || LA74_1 == Identifier || (LA74_1 >= LBRACE && LA74_1 <= LBRACK) || LA74_1 == LPAREN || (LA74_1 >= NEW && LA74_1 <= NOT) || LA74_1 == NULL || LA74_1 == OctalIntegerLiteral || LA74_1 == RETURN || LA74_1 == RegularExpressionLiteral || LA74_1 == SEMIC || LA74_1 == SUB || LA74_1 == SWITCH || LA74_1 == StringLiteral || (LA74_1 >= THIS && LA74_1 <= THROW) || (LA74_1 >= TRUE && LA74_1 <= TYPEOF) || (LA74_1 >= VAR && LA74_1 <= VOID) || (LA74_1 >= WHILE && LA74_1 <= WITH)))
                            {
                                alt74 = 1;
                            }
                        }
                        finally { DebugExitDecision(74); }
                        switch (alt74)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1704:14: functionDeclarationBodyWithoutBraces
                                {
                                    DebugLocation(1704, 14);
                                    PushFollow(Follow._functionDeclarationBodyWithoutBraces_in_functionDeclarationBody5722);
                                    functionDeclarationBodyWithoutBraces();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(74); }

                    DebugLocation(1704, 52);
                    Match(input, RBRACE, Follow._RBRACE_in_functionDeclarationBody5725);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionDeclarationBody", 81);
                LeaveRule("functionDeclarationBody", 81);
                LeaveRule_functionDeclarationBody();
            }
            DebugLocation(1705, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionDeclarationBody"); }
        return retval;

    }
    // $ANTLR end "functionDeclarationBody"

    partial void EnterRule_functionExpressionBody();
    partial void LeaveRule_functionExpressionBody();
    // $ANTLR start "functionExpressionBody"
    // ES3YUITest.g:1707:1: functionExpressionBody : lb= LBRACE ( functionExpressionBodyWithoutBraces )? RBRACE ;
    [GrammarRule("functionExpressionBody")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionExpressionBody()
    {
        EnterRule_functionExpressionBody();
        EnterRule("functionExpressionBody", 82);
        TraceIn("functionExpressionBody", 82);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        IToken lb = default(IToken);

        try
        {
            DebugEnterRule(GrammarFileName, "functionExpressionBody");
            DebugLocation(1707, 1);
            try
            {
                // ES3YUITest.g:1708:2: (lb= LBRACE ( functionExpressionBodyWithoutBraces )? RBRACE )
                DebugEnterAlt(1);
                // ES3YUITest.g:1708:4: lb= LBRACE ( functionExpressionBodyWithoutBraces )? RBRACE
                {
                    DebugLocation(1708, 6);
                    lb = (IToken)Match(input, LBRACE, Follow._LBRACE_in_functionExpressionBody5738);
                    DebugLocation(1708, 14);
                    // ES3YUITest.g:1708:14: ( functionExpressionBodyWithoutBraces )?
                    int alt75 = 2;
                    try
                    {
                        DebugEnterSubRule(75);
                        try
                        {
                            DebugEnterDecision(75, false);
                            int LA75_1 = input.LA(1);

                            if ((LA75_1 == ADD || LA75_1 == BREAK || LA75_1 == CONTINUE || LA75_1 == DEC || LA75_1 == DELETE || LA75_1 == DO || LA75_1 == DecimalLiteral || LA75_1 == FALSE || LA75_1 == FOR || LA75_1 == FUNCTION || (LA75_1 >= HexIntegerLiteral && LA75_1 <= IF) || LA75_1 == INC || LA75_1 == INV || LA75_1 == Identifier || (LA75_1 >= LBRACE && LA75_1 <= LBRACK) || LA75_1 == LPAREN || (LA75_1 >= NEW && LA75_1 <= NOT) || LA75_1 == NULL || LA75_1 == OctalIntegerLiteral || LA75_1 == RETURN || LA75_1 == RegularExpressionLiteral || LA75_1 == SEMIC || LA75_1 == SUB || LA75_1 == SWITCH || LA75_1 == StringLiteral || (LA75_1 >= THIS && LA75_1 <= THROW) || (LA75_1 >= TRUE && LA75_1 <= TYPEOF) || (LA75_1 >= VAR && LA75_1 <= VOID) || (LA75_1 >= WHILE && LA75_1 <= WITH)))
                            {
                                alt75 = 1;
                            }
                        }
                        finally { DebugExitDecision(75); }
                        switch (alt75)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // ES3YUITest.g:1708:14: functionExpressionBodyWithoutBraces
                                {
                                    DebugLocation(1708, 14);
                                    PushFollow(Follow._functionExpressionBodyWithoutBraces_in_functionExpressionBody5740);
                                    functionExpressionBodyWithoutBraces();
                                    PopFollow();


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(75); }

                    DebugLocation(1708, 51);
                    Match(input, RBRACE, Follow._RBRACE_in_functionExpressionBody5743);

                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionExpressionBody", 82);
                LeaveRule("functionExpressionBody", 82);
                LeaveRule_functionExpressionBody();
            }
            DebugLocation(1709, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionExpressionBody"); }
        return retval;

    }
    // $ANTLR end "functionExpressionBody"

    partial void EnterRule_functionExpressionBodyWithoutBraces();
    partial void LeaveRule_functionExpressionBodyWithoutBraces();
    // $ANTLR start "functionExpressionBodyWithoutBraces"
    // ES3YUITest.g:1712:1: functionExpressionBodyWithoutBraces : sourceElement ( sourceElement )* -> {$functionExpression::funcName!=null}? cover_func(src=$program::namecode=$textname=$functionExpression::funcNameline=$functionExpression::funcLine) -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine);
    [GrammarRule("functionExpressionBodyWithoutBraces")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionExpressionBodyWithoutBraces()
    {
        EnterRule_functionExpressionBodyWithoutBraces();
        EnterRule("functionExpressionBodyWithoutBraces", 83);
        TraceIn("functionExpressionBodyWithoutBraces", 83);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "functionExpressionBodyWithoutBraces");
            DebugLocation(1712, 1);
            try
            {
                // ES3YUITest.g:1722:2: ( sourceElement ( sourceElement )* -> {$functionExpression::funcName!=null}? cover_func(src=$program::namecode=$textname=$functionExpression::funcNameline=$functionExpression::funcLine) -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine))
                DebugEnterAlt(1);
                // ES3YUITest.g:1722:4: sourceElement ( sourceElement )*
                {
                    DebugLocation(1722, 4);
                    PushFollow(Follow._sourceElement_in_functionExpressionBodyWithoutBraces5760);
                    sourceElement();
                    PopFollow();

                    DebugLocation(1722, 18);
                    // ES3YUITest.g:1722:18: ( sourceElement )*
                    try
                    {
                        DebugEnterSubRule(76);
                        while (true)
                        {
                            int alt76 = 2;
                            try
                            {
                                DebugEnterDecision(76, false);
                                int LA76_1 = input.LA(1);

                                if ((LA76_1 == ADD || LA76_1 == BREAK || LA76_1 == CONTINUE || LA76_1 == DEC || LA76_1 == DELETE || LA76_1 == DO || LA76_1 == DecimalLiteral || LA76_1 == FALSE || LA76_1 == FOR || LA76_1 == FUNCTION || (LA76_1 >= HexIntegerLiteral && LA76_1 <= IF) || LA76_1 == INC || LA76_1 == INV || LA76_1 == Identifier || (LA76_1 >= LBRACE && LA76_1 <= LBRACK) || LA76_1 == LPAREN || (LA76_1 >= NEW && LA76_1 <= NOT) || LA76_1 == NULL || LA76_1 == OctalIntegerLiteral || LA76_1 == RETURN || LA76_1 == RegularExpressionLiteral || LA76_1 == SEMIC || LA76_1 == SUB || LA76_1 == SWITCH || LA76_1 == StringLiteral || (LA76_1 >= THIS && LA76_1 <= THROW) || (LA76_1 >= TRUE && LA76_1 <= TYPEOF) || (LA76_1 >= VAR && LA76_1 <= VOID) || (LA76_1 >= WHILE && LA76_1 <= WITH)))
                                {
                                    alt76 = 1;
                                }


                            }
                            finally { DebugExitDecision(76); }
                            switch (alt76)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1722:18: sourceElement
                                    {
                                        DebugLocation(1722, 18);
                                        PushFollow(Follow._sourceElement_in_functionExpressionBodyWithoutBraces5762);
                                        sourceElement();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop76;
                            }
                        }

                    loop76:
                        ;

                    }
                    finally { DebugExitSubRule(76); }

                    DebugLocation(1723, 2);




                    // TEMPLATE REWRITE
                    // 1726:2: -> {$functionExpression::funcName!=null}? cover_func(src=$program::namecode=$textname=$functionExpression::funcNameline=$functionExpression::funcLine)
                    if (functionExpression_stack.Peek().funcName != null)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_func",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "name", functionExpression_stack.Peek().funcName }, { "line", functionExpression_stack.Peek().funcLine } }
                    );
                    }

                    else // 1727:2: -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_func",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "name", functionDeclaration_stack.Peek().funcName }, { "line", functionDeclaration_stack.Peek().funcLine } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);


                //favor the function expression's declared name, otherwise assign an anonymous function name
                program_stack.Peek().functions.Add("\"" + functionExpression_stack.Peek().funcName + ":" + functionExpression_stack.Peek().funcLine + "\"");

                if (Verbose)
                {
                    Console.WriteLine("\n[INFO] Instrumenting function expression '" + functionExpression_stack.Peek().funcName + "' on line " + functionExpression_stack.Peek().funcLine);
                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionExpressionBodyWithoutBraces", 83);
                LeaveRule("functionExpressionBodyWithoutBraces", 83);
                LeaveRule_functionExpressionBodyWithoutBraces();
            }
            DebugLocation(1728, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionExpressionBodyWithoutBraces"); }
        return retval;

    }
    // $ANTLR end "functionExpressionBodyWithoutBraces"

    partial void EnterRule_functionDeclarationBodyWithoutBraces();
    partial void LeaveRule_functionDeclarationBodyWithoutBraces();
    // $ANTLR start "functionDeclarationBodyWithoutBraces"
    // ES3YUITest.g:1730:1: functionDeclarationBodyWithoutBraces : sourceElement ( sourceElement )* -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine);
    [GrammarRule("functionDeclarationBodyWithoutBraces")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> functionDeclarationBodyWithoutBraces()
    {
        EnterRule_functionDeclarationBodyWithoutBraces();
        EnterRule("functionDeclarationBodyWithoutBraces", 84);
        TraceIn("functionDeclarationBodyWithoutBraces", 84);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "functionDeclarationBodyWithoutBraces");
            DebugLocation(1730, 1);
            try
            {
                // ES3YUITest.g:1731:2: ( sourceElement ( sourceElement )* -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine))
                DebugEnterAlt(1);
                // ES3YUITest.g:1731:4: sourceElement ( sourceElement )*
                {
                    DebugLocation(1731, 4);
                    PushFollow(Follow._sourceElement_in_functionDeclarationBodyWithoutBraces5829);
                    sourceElement();
                    PopFollow();

                    DebugLocation(1731, 18);
                    // ES3YUITest.g:1731:18: ( sourceElement )*
                    try
                    {
                        DebugEnterSubRule(77);
                        while (true)
                        {
                            int alt77 = 2;
                            try
                            {
                                DebugEnterDecision(77, false);
                                int LA77_1 = input.LA(1);

                                if ((LA77_1 == ADD || LA77_1 == BREAK || LA77_1 == CONTINUE || LA77_1 == DEC || LA77_1 == DELETE || LA77_1 == DO || LA77_1 == DecimalLiteral || LA77_1 == FALSE || LA77_1 == FOR || LA77_1 == FUNCTION || (LA77_1 >= HexIntegerLiteral && LA77_1 <= IF) || LA77_1 == INC || LA77_1 == INV || LA77_1 == Identifier || (LA77_1 >= LBRACE && LA77_1 <= LBRACK) || LA77_1 == LPAREN || (LA77_1 >= NEW && LA77_1 <= NOT) || LA77_1 == NULL || LA77_1 == OctalIntegerLiteral || LA77_1 == RETURN || LA77_1 == RegularExpressionLiteral || LA77_1 == SEMIC || LA77_1 == SUB || LA77_1 == SWITCH || LA77_1 == StringLiteral || (LA77_1 >= THIS && LA77_1 <= THROW) || (LA77_1 >= TRUE && LA77_1 <= TYPEOF) || (LA77_1 >= VAR && LA77_1 <= VOID) || (LA77_1 >= WHILE && LA77_1 <= WITH)))
                                {
                                    alt77 = 1;
                                }


                            }
                            finally { DebugExitDecision(77); }
                            switch (alt77)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // ES3YUITest.g:1731:18: sourceElement
                                    {
                                        DebugLocation(1731, 18);
                                        PushFollow(Follow._sourceElement_in_functionDeclarationBodyWithoutBraces5831);
                                        sourceElement();
                                        PopFollow();


                                    }
                                    break;

                                default:
                                    goto loop77;
                            }
                        }

                    loop77:
                        ;

                    }
                    finally { DebugExitSubRule(77); }


                    // TEMPLATE REWRITE
                    // 1732:2: -> cover_func(src=$program::namecode=$textname=$functionDeclaration::funcNameline=$functionDeclaration::funcLine)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_func",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "name", functionDeclaration_stack.Peek().funcName }, { "line", functionDeclaration_stack.Peek().funcLine } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("functionDeclarationBodyWithoutBraces", 84);
                LeaveRule("functionDeclarationBodyWithoutBraces", 84);
                LeaveRule_functionDeclarationBodyWithoutBraces();
            }
            DebugLocation(1733, 1);
        }
        finally { DebugExitRule(GrammarFileName, "functionDeclarationBodyWithoutBraces"); }
        return retval;

    }
    // $ANTLR end "functionDeclarationBodyWithoutBraces"

    protected sealed partial class program_scope
    {
        public List<int> executableLines;
        public List<string> functions;
        public int stopLine;
        public string name;
        public int anonymousFunctionCount;

        public program_scope(ES3YUITestParser grammar) { OnCreated(grammar); }
        partial void OnCreated(ES3YUITestParser grammar);
    }
    partial void program_scopeInit(program_scope scope);
    partial void program_scopeAfter(program_scope scope);
    protected readonly ListStack<program_scope> program_stack = new ListStack<program_scope>();

    partial void EnterRule_program();
    partial void LeaveRule_program();
    // $ANTLR start "program"
    // ES3YUITest.g:1739:1: program : ( ( sourceElement )* ) -> cover_file(src=$program::namecode=$textlines=ToObjectLiteral($program::executableLines, true)funcs=ToObjectLiteral($program::functions, false)lineCount=$program::executableLines.CountfuncCount=$program::functions.Count);
    [GrammarRule("program")]
    public TemplateParserRuleReturnScope<StringTemplate, IToken> program()
    {
        EnterRule_program();
        EnterRule("program", 85);
        TraceIn("program", 85);
        program_stack.Push(new program_scope(this)); program_scopeInit(program_stack.Peek());
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);


        program_stack.Peek().executableLines = new List<int>();
        program_stack.Peek().functions = new List<string>();
        program_stack.Peek().stopLine = 0;
        program_stack.Peek().name = SourceFileName;
        program_stack.Peek().anonymousFunctionCount = 0;

        try
        {
            DebugEnterRule(GrammarFileName, "program");
            DebugLocation(1739, 1);
            try
            {
                // ES3YUITest.g:1754:2: ( ( ( sourceElement )* ) -> cover_file(src=$program::namecode=$textlines=ToObjectLiteral($program::executableLines, true)funcs=ToObjectLiteral($program::functions, false)lineCount=$program::executableLines.CountfuncCount=$program::functions.Count))
                DebugEnterAlt(1);
                // ES3YUITest.g:1754:4: ( ( sourceElement )* )
                {
                    DebugLocation(1754, 4);
                    // ES3YUITest.g:1754:4: ( ( sourceElement )* )
                    DebugEnterAlt(1);
                    // ES3YUITest.g:1754:5: ( sourceElement )*
                    {
                        DebugLocation(1754, 5);
                        // ES3YUITest.g:1754:5: ( sourceElement )*
                        try
                        {
                            DebugEnterSubRule(78);
                            while (true)
                            {
                                int alt78 = 2;
                                try
                                {
                                    DebugEnterDecision(78, false);
                                    int LA78_1 = input.LA(1);

                                    if ((LA78_1 == ADD || LA78_1 == BREAK || LA78_1 == CONTINUE || LA78_1 == DEC || LA78_1 == DELETE || LA78_1 == DO || LA78_1 == DecimalLiteral || LA78_1 == FALSE || LA78_1 == FOR || LA78_1 == FUNCTION || (LA78_1 >= HexIntegerLiteral && LA78_1 <= IF) || LA78_1 == INC || LA78_1 == INV || LA78_1 == Identifier || (LA78_1 >= LBRACE && LA78_1 <= LBRACK) || LA78_1 == LPAREN || (LA78_1 >= NEW && LA78_1 <= NOT) || LA78_1 == NULL || LA78_1 == OctalIntegerLiteral || LA78_1 == RETURN || LA78_1 == RegularExpressionLiteral || LA78_1 == SEMIC || LA78_1 == SUB || LA78_1 == SWITCH || LA78_1 == StringLiteral || (LA78_1 >= THIS && LA78_1 <= THROW) || (LA78_1 >= TRUE && LA78_1 <= TYPEOF) || (LA78_1 >= VAR && LA78_1 <= VOID) || (LA78_1 >= WHILE && LA78_1 <= WITH)))
                                    {
                                        alt78 = 1;
                                    }


                                }
                                finally { DebugExitDecision(78); }
                                switch (alt78)
                                {
                                    case 1:
                                        DebugEnterAlt(1);
                                        // ES3YUITest.g:1754:5: sourceElement
                                        {
                                            DebugLocation(1754, 5);
                                            PushFollow(Follow._sourceElement_in_program5883);
                                            sourceElement();
                                            PopFollow();


                                        }
                                        break;

                                    default:
                                        goto loop78;
                                }
                            }

                        loop78:
                            ;

                        }
                        finally { DebugExitSubRule(78); }


                    }

                    DebugLocation(1754, 21);
                    program_stack.Peek().executableLines.Sort();

                    // TEMPLATE REWRITE
                    // 1755:2: -> cover_file(src=$program::namecode=$textlines=ToObjectLiteral($program::executableLines, true)funcs=ToObjectLiteral($program::functions, false)lineCount=$program::executableLines.CountfuncCount=$program::functions.Count)
                    {
                        retval.Template = TemplateGroup.GetInstanceOf("cover_file",
                        new Dictionary<string, object>() { { "src", program_stack.Peek().name }, { "code", input.ToString(retval.Start, input.LT(-1)) }, { "lines", ToObjectLiteral(program_stack.Peek().executableLines, true) }, { "funcs", ToObjectLiteral(program_stack.Peek().functions, false) }, { "lineCount", program_stack.Peek().executableLines.Count }, { "funcCount", program_stack.Peek().functions.Count } }
                    );
                    }


                    ((TokenRewriteStream)input).Replace(
                        retval.Start.TokenIndex,
                        input.LT(-1).TokenIndex,
                        retval.Template);


                }

                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("program", 85);
                LeaveRule("program", 85);
                LeaveRule_program();
                program_scopeAfter(program_stack.Peek()); program_stack.Pop();
            }
            DebugLocation(1756, 1);
        }
        finally { DebugExitRule(GrammarFileName, "program"); }
        return retval;

    }
    // $ANTLR end "program"

    partial void EnterRule_sourceElement();
    partial void LeaveRule_sourceElement();
    // $ANTLR start "sourceElement"
    // ES3YUITest.g:1763:1: sourceElement options {k=1; } : ({...}? functionDeclaration | statement );
    [GrammarRule("sourceElement")]
    private TemplateParserRuleReturnScope<StringTemplate, IToken> sourceElement()
    {
        EnterRule_sourceElement();
        EnterRule("sourceElement", 86);
        TraceIn("sourceElement", 86);
        TemplateParserRuleReturnScope<StringTemplate, IToken> retval = new TemplateParserRuleReturnScope<StringTemplate, IToken>();
        retval.Start = (IToken)input.LT(1);

        try
        {
            DebugEnterRule(GrammarFileName, "sourceElement");
            DebugLocation(1763, 1);
            try
            {
                // ES3YUITest.g:1768:2: ({...}? functionDeclaration | statement )
                int alt79 = 2;
                try
                {
                    DebugEnterDecision(79, false);
                    int LA79_1 = input.LA(1);

                    if ((LA79_1 == FUNCTION))
                    {
                        int LA79_2 = input.LA(2);

                        if (((input.LA(1) == FUNCTION)))
                        {
                            alt79 = 1;
                        }
                        else if ((true))
                        {
                            alt79 = 2;
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 79, 1, input, 2);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    else if ((LA79_1 == ADD || LA79_1 == BREAK || LA79_1 == CONTINUE || LA79_1 == DEC || LA79_1 == DELETE || LA79_1 == DO || LA79_1 == DecimalLiteral || LA79_1 == FALSE || LA79_1 == FOR || (LA79_1 >= HexIntegerLiteral && LA79_1 <= IF) || LA79_1 == INC || LA79_1 == INV || LA79_1 == Identifier || (LA79_1 >= LBRACE && LA79_1 <= LBRACK) || LA79_1 == LPAREN || (LA79_1 >= NEW && LA79_1 <= NOT) || LA79_1 == NULL || LA79_1 == OctalIntegerLiteral || LA79_1 == RETURN || LA79_1 == RegularExpressionLiteral || LA79_1 == SEMIC || LA79_1 == SUB || LA79_1 == SWITCH || LA79_1 == StringLiteral || (LA79_1 >= THIS && LA79_1 <= THROW) || (LA79_1 >= TRUE && LA79_1 <= TYPEOF) || (LA79_1 >= VAR && LA79_1 <= VOID) || (LA79_1 >= WHILE && LA79_1 <= WITH)))
                    {
                        alt79 = 2;
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 79, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(79); }
                switch (alt79)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // ES3YUITest.g:1768:4: {...}? functionDeclaration
                        {
                            DebugLocation(1768, 4);
                            if (!((input.LA(1) == FUNCTION)))
                            {
                                throw new FailedPredicateException(input, "sourceElement", " input.LA(1) == FUNCTION ");
                            }
                            DebugLocation(1768, 33);
                            PushFollow(Follow._functionDeclaration_in_sourceElement5954);
                            functionDeclaration();
                            PopFollow();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // ES3YUITest.g:1769:4: statement
                        {
                            DebugLocation(1769, 4);
                            PushFollow(Follow._statement_in_sourceElement5959);
                            statement();
                            PopFollow();


                        }
                        break;

                }
                retval.Stop = (IToken)input.LT(-1);

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("sourceElement", 86);
                LeaveRule("sourceElement", 86);
                LeaveRule_sourceElement();
            }
            DebugLocation(1770, 1);
        }
        finally { DebugExitRule(GrammarFileName, "sourceElement"); }
        return retval;

    }
    // $ANTLR end "sourceElement"
    #endregion Rules


    #region Follow sets
    private static class Follow
    {
        public static readonly BitSet _reservedWord_in_token1763 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _Identifier_in_token1768 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _punctuator_in_token1773 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _numericLiteral_in_token1778 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _StringLiteral_in_token1783 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _keyword_in_reservedWord1796 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _futureReservedWord_in_reservedWord1801 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NULL_in_reservedWord1806 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _booleanLiteral_in_reservedWord1811 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NULL_in_literal2492 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _booleanLiteral_in_literal2497 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _numericLiteral_in_literal2502 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _StringLiteral_in_literal2507 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _RegularExpressionLiteral_in_literal2512 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _THIS_in_primaryExpression3125 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _Identifier_in_primaryExpression3130 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _literal_in_primaryExpression3135 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _arrayLiteral_in_primaryExpression3140 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _objectLiteral_in_primaryExpression3145 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LPAREN_in_primaryExpression3152 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_primaryExpression3154 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_primaryExpression3156 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LBRACK_in_arrayLiteral3172 = new BitSet(new ulong[] { 0x4040100A08000020UL, 0x400416000460A210UL, 0x451410008UL });
        public static readonly BitSet _arrayItem_in_arrayLiteral3176 = new BitSet(new ulong[] { 0x8000000UL, 0x4000000000000000UL });
        public static readonly BitSet _COMMA_in_arrayLiteral3180 = new BitSet(new ulong[] { 0x4040100A08000020UL, 0x400416000460A210UL, 0x451410008UL });
        public static readonly BitSet _arrayItem_in_arrayLiteral3182 = new BitSet(new ulong[] { 0x8000000UL, 0x4000000000000000UL });
        public static readonly BitSet _RBRACK_in_arrayLiteral3191 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _assignmentExpression_in_arrayItem3208 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LBRACE_in_objectLiteral3229 = new BitSet(new ulong[] { 0x100000000000UL, 0x2004000000008010UL, 0x400000UL });
        public static readonly BitSet _nameValuePair_in_objectLiteral3233 = new BitSet(new ulong[] { 0x8000000UL, 0x2000000000000000UL });
        public static readonly BitSet _COMMA_in_objectLiteral3237 = new BitSet(new ulong[] { 0x100000000000UL, 0x4000000008010UL, 0x400000UL });
        public static readonly BitSet _nameValuePair_in_objectLiteral3239 = new BitSet(new ulong[] { 0x8000000UL, 0x2000000000000000UL });
        public static readonly BitSet _RBRACE_in_objectLiteral3247 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _propertyName_in_nameValuePair3263 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_nameValuePair3265 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_nameValuePair3267 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _Identifier_in_propertyName3280 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _StringLiteral_in_propertyName3285 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _numericLiteral_in_propertyName3290 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _primaryExpression_in_memberExpression3308 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _functionExpression_in_memberExpression3313 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _newExpression_in_memberExpression3318 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NEW_in_newExpression3329 = new BitSet(new ulong[] { 0x40100000000000UL, 0x4100004608010UL, 0x11400008UL });
        public static readonly BitSet _primaryExpression_in_newExpression3331 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NEW_in_newExpression3343 = new BitSet(new ulong[] { 0x4000000000000000UL });
        public static readonly BitSet _functionExpression_in_newExpression3345 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LPAREN_in_arguments3361 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410009UL });
        public static readonly BitSet _assignmentExpression_in_arguments3365 = new BitSet(new ulong[] { 0x8000000UL, 0x0UL, 0x1UL });
        public static readonly BitSet _COMMA_in_arguments3369 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_arguments3371 = new BitSet(new ulong[] { 0x8000000UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_arguments3379 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _memberExpression_in_leftHandSideExpression3398 = new BitSet(new ulong[] { 0x8000000002UL, 0x4400000UL });
        public static readonly BitSet _arguments_in_leftHandSideExpression3411 = new BitSet(new ulong[] { 0x8000000002UL, 0x4400000UL });
        public static readonly BitSet _LBRACK_in_leftHandSideExpression3420 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_leftHandSideExpression3422 = new BitSet(new ulong[] { 0x0UL, 0x4000000000000000UL });
        public static readonly BitSet _RBRACK_in_leftHandSideExpression3424 = new BitSet(new ulong[] { 0x8000000002UL, 0x4400000UL });
        public static readonly BitSet _DOT_in_leftHandSideExpression3431 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _Identifier_in_leftHandSideExpression3433 = new BitSet(new ulong[] { 0x8000000002UL, 0x4400000UL });
        public static readonly BitSet _leftHandSideExpression_in_postfixExpression3456 = new BitSet(new ulong[] { 0x200000002UL, 0x200UL });
        public static readonly BitSet _postfixOperator_in_postfixExpression3462 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _INC_in_postfixOperator3479 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _DEC_in_postfixOperator3488 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _postfixExpression_in_unaryExpression3505 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _unaryOperator_in_unaryExpression3510 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _unaryExpression_in_unaryExpression3512 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _DELETE_in_unaryOperator3524 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _VOID_in_unaryOperator3529 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _TYPEOF_in_unaryOperator3534 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _INC_in_unaryOperator3539 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _DEC_in_unaryOperator3544 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _ADD_in_unaryOperator3551 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _SUB_in_unaryOperator3560 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _INV_in_unaryOperator3567 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NOT_in_unaryOperator3572 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _unaryExpression_in_multiplicativeExpression3587 = new BitSet(new ulong[] { 0x1000000002UL, 0x280000000UL });
        public static readonly BitSet _set_in_multiplicativeExpression3591 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _unaryExpression_in_multiplicativeExpression3605 = new BitSet(new ulong[] { 0x1000000002UL, 0x280000000UL });
        public static readonly BitSet _multiplicativeExpression_in_additiveExpression3623 = new BitSet(new ulong[] { 0x22UL, 0x0UL, 0x10000UL });
        public static readonly BitSet _set_in_additiveExpression3627 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _multiplicativeExpression_in_additiveExpression3637 = new BitSet(new ulong[] { 0x22UL, 0x0UL, 0x10000UL });
        public static readonly BitSet _additiveExpression_in_shiftExpression3656 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0xA40UL });
        public static readonly BitSet _set_in_shiftExpression3660 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _additiveExpression_in_shiftExpression3674 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0xA40UL });
        public static readonly BitSet _shiftExpression_in_relationalExpression3693 = new BitSet(new ulong[] { 0x2UL, 0x30000503UL });
        public static readonly BitSet _set_in_relationalExpression3697 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _shiftExpression_in_relationalExpression3723 = new BitSet(new ulong[] { 0x2UL, 0x30000503UL });
        public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn3737 = new BitSet(new ulong[] { 0x2UL, 0x30000403UL });
        public static readonly BitSet _set_in_relationalExpressionNoIn3741 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn3763 = new BitSet(new ulong[] { 0x2UL, 0x30000403UL });
        public static readonly BitSet _relationalExpression_in_equalityExpression3782 = new BitSet(new ulong[] { 0x1000000000002UL, 0x90000000000UL, 0x10UL });
        public static readonly BitSet _set_in_equalityExpression3786 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _relationalExpression_in_equalityExpression3804 = new BitSet(new ulong[] { 0x1000000000002UL, 0x90000000000UL, 0x10UL });
        public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn3818 = new BitSet(new ulong[] { 0x1000000000002UL, 0x90000000000UL, 0x10UL });
        public static readonly BitSet _set_in_equalityExpressionNoIn3822 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn3840 = new BitSet(new ulong[] { 0x1000000000002UL, 0x90000000000UL, 0x10UL });
        public static readonly BitSet _equalityExpression_in_bitwiseANDExpression3860 = new BitSet(new ulong[] { 0x82UL });
        public static readonly BitSet _AND_in_bitwiseANDExpression3864 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _equalityExpression_in_bitwiseANDExpression3866 = new BitSet(new ulong[] { 0x82UL });
        public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3880 = new BitSet(new ulong[] { 0x82UL });
        public static readonly BitSet _AND_in_bitwiseANDExpressionNoIn3884 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3886 = new BitSet(new ulong[] { 0x82UL });
        public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3902 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0x10000000000UL });
        public static readonly BitSet _XOR_in_bitwiseXORExpression3906 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3908 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0x10000000000UL });
        public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn3924 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0x10000000000UL });
        public static readonly BitSet _XOR_in_bitwiseXORExpressionNoIn3928 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn3930 = new BitSet(new ulong[] { 0x2UL, 0x0UL, 0x10000000000UL });
        public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression3945 = new BitSet(new ulong[] { 0x2UL, 0x400000000000UL });
        public static readonly BitSet _OR_in_bitwiseORExpression3949 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression3951 = new BitSet(new ulong[] { 0x2UL, 0x400000000000UL });
        public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3966 = new BitSet(new ulong[] { 0x2UL, 0x400000000000UL });
        public static readonly BitSet _OR_in_bitwiseORExpressionNoIn3970 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3972 = new BitSet(new ulong[] { 0x2UL, 0x400000000000UL });
        public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression3991 = new BitSet(new ulong[] { 0x2UL, 0x100000UL });
        public static readonly BitSet _LAND_in_logicalANDExpression3995 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression3997 = new BitSet(new ulong[] { 0x2UL, 0x100000UL });
        public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4011 = new BitSet(new ulong[] { 0x2UL, 0x100000UL });
        public static readonly BitSet _LAND_in_logicalANDExpressionNoIn4015 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4017 = new BitSet(new ulong[] { 0x2UL, 0x100000UL });
        public static readonly BitSet _logicalANDExpression_in_logicalORExpression4032 = new BitSet(new ulong[] { 0x2UL, 0x2000000UL });
        public static readonly BitSet _LOR_in_logicalORExpression4036 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _logicalANDExpression_in_logicalORExpression4038 = new BitSet(new ulong[] { 0x2UL, 0x2000000UL });
        public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn4053 = new BitSet(new ulong[] { 0x2UL, 0x2000000UL });
        public static readonly BitSet _LOR_in_logicalORExpressionNoIn4057 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn4059 = new BitSet(new ulong[] { 0x2UL, 0x2000000UL });
        public static readonly BitSet _logicalORExpression_in_conditionalExpression4078 = new BitSet(new ulong[] { 0x2UL, 0x1000000000000000UL });
        public static readonly BitSet _QUE_in_conditionalExpression4082 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_conditionalExpression4084 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_conditionalExpression4086 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_conditionalExpression4088 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn4102 = new BitSet(new ulong[] { 0x2UL, 0x1000000000000000UL });
        public static readonly BitSet _QUE_in_conditionalExpressionNoIn4106 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn4108 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_conditionalExpressionNoIn4110 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn4112 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _conditionalExpression_in_assignmentExpression4140 = new BitSet(new ulong[] { 0x2000000942UL, 0x800500000000UL, 0x20000021480UL });
        public static readonly BitSet _assignmentOperator_in_assignmentExpression4147 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_assignmentExpression4149 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn4226 = new BitSet(new ulong[] { 0x2000000942UL, 0x800500000000UL, 0x20000021480UL });
        public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn4233 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn4235 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _assignmentExpression_in_expression4257 = new BitSet(new ulong[] { 0x8000002UL });
        public static readonly BitSet _COMMA_in_expression4261 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_expression4265 = new BitSet(new ulong[] { 0x8000002UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn4285 = new BitSet(new ulong[] { 0x8000002UL });
        public static readonly BitSet _COMMA_in_expressionNoIn4289 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn4293 = new BitSet(new ulong[] { 0x8000002UL });
        public static readonly BitSet _SEMIC_in_semic4327 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _EOF_in_semic4332 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _RBRACE_in_semic4337 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _EOL_in_semic4344 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _MultiLineComment_in_semic4348 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _block_in_statement4391 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _statementTail_in_statement4395 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _variableStatement_in_statementTail4443 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _emptyStatement_in_statementTail4448 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _expressionStatement_in_statementTail4453 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _ifStatement_in_statementTail4458 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _iterationStatement_in_statementTail4463 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _continueStatement_in_statementTail4468 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _breakStatement_in_statementTail4473 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _returnStatement_in_statementTail4478 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _withStatement_in_statementTail4483 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _labelledStatement_in_statementTail4488 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _switchStatement_in_statementTail4493 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _throwStatement_in_statementTail4498 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _tryStatement_in_statementTail4503 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LBRACE_in_block4518 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0xA00416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_block4520 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0xA00416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _RBRACE_in_block4523 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _VAR_in_variableStatement4541 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _variableDeclaration_in_variableStatement4543 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _COMMA_in_variableStatement4547 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _variableDeclaration_in_variableStatement4549 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_variableStatement4554 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _Identifier_in_variableDeclaration4567 = new BitSet(new ulong[] { 0x802UL });
        public static readonly BitSet _ASSIGN_in_variableDeclaration4571 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpression_in_variableDeclaration4573 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _Identifier_in_variableDeclarationNoIn4588 = new BitSet(new ulong[] { 0x802UL });
        public static readonly BitSet _ASSIGN_in_variableDeclarationNoIn4592 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _assignmentExpressionNoIn_in_variableDeclarationNoIn4594 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _SEMIC_in_emptyStatement4613 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _expression_in_expressionStatement4631 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_expressionStatement4633 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _IF_in_ifStatement4651 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_ifStatement4653 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_ifStatement4655 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_ifStatement4657 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_ifStatement4659 = new BitSet(new ulong[] { 0x200000000002UL });
        public static readonly BitSet _elseStatement_in_ifStatement4665 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _ELSE_in_elseStatement4737 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_elseStatement4739 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _doStatement_in_iterationStatement4776 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _whileStatement_in_iterationStatement4781 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _forStatement_in_iterationStatement4786 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _DO_in_doStatement4798 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_doStatement4800 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x2000000000UL });
        public static readonly BitSet _WHILE_in_doStatement4802 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_doStatement4804 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_doStatement4806 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_doStatement4808 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_doStatement4810 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _WHILE_in_whileStatement4896 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_whileStatement4898 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_whileStatement4900 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_whileStatement4902 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_whileStatement4904 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _FOR_in_forStatement4965 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_forStatement4967 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x651410028UL });
        public static readonly BitSet _forControl_in_forStatement4969 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_forStatement4971 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_forStatement4973 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _forControlVar_in_forControl5032 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _forControlExpression_in_forControl5037 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _forControlSemic_in_forControl5042 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _VAR_in_forControlVar5053 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _variableDeclarationNoIn_in_forControlVar5055 = new BitSet(new ulong[] { 0x8000000UL, 0x100UL, 0x20UL });
        public static readonly BitSet _IN_in_forControlVar5067 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_forControlVar5069 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _COMMA_in_forControlVar5092 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _variableDeclarationNoIn_in_forControlVar5094 = new BitSet(new ulong[] { 0x8000000UL, 0x0UL, 0x20UL });
        public static readonly BitSet _SEMIC_in_forControlVar5099 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410028UL });
        public static readonly BitSet _expression_in_forControlVar5103 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x20UL });
        public static readonly BitSet _SEMIC_in_forControlVar5106 = new BitSet(new ulong[] { 0x4040100A00000022UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_forControlVar5110 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _expressionNoIn_in_forControlExpression5140 = new BitSet(new ulong[] { 0x0UL, 0x100UL, 0x20UL });
        public static readonly BitSet _IN_in_forControlExpression5155 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_forControlExpression5159 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _SEMIC_in_forControlExpression5180 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410028UL });
        public static readonly BitSet _expression_in_forControlExpression5184 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x20UL });
        public static readonly BitSet _SEMIC_in_forControlExpression5187 = new BitSet(new ulong[] { 0x4040100A00000022UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_forControlExpression5191 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _SEMIC_in_forControlSemic5214 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410028UL });
        public static readonly BitSet _expression_in_forControlSemic5218 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x20UL });
        public static readonly BitSet _SEMIC_in_forControlSemic5221 = new BitSet(new ulong[] { 0x4040100A00000022UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_forControlSemic5225 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _CONTINUE_in_continueStatement5246 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _Identifier_in_continueStatement5250 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_continueStatement5253 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _BREAK_in_breakStatement5271 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _Identifier_in_breakStatement5275 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_breakStatement5278 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _RETURN_in_returnStatement5296 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _expression_in_returnStatement5300 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_returnStatement5303 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _WITH_in_withStatement5319 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_withStatement5321 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_withStatement5323 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_withStatement5325 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_withStatement5327 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _SWITCH_in_switchStatement5396 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_switchStatement5398 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_switchStatement5400 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_switchStatement5402 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _LBRACE_in_switchStatement5404 = new BitSet(new ulong[] { 0x400200000UL, 0x2000000000000000UL });
        public static readonly BitSet _defaultClause_in_switchStatement5411 = new BitSet(new ulong[] { 0x400200000UL, 0x2000000000000000UL });
        public static readonly BitSet _caseClause_in_switchStatement5417 = new BitSet(new ulong[] { 0x400200000UL, 0x2000000000000000UL });
        public static readonly BitSet _RBRACE_in_switchStatement5422 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _CASE_in_caseClause5435 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_caseClause5437 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_caseClause5439 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_caseClause5441 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _DEFAULT_in_defaultClause5454 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_defaultClause5456 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_defaultClause5458 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _Identifier_in_labelledStatement5475 = new BitSet(new ulong[] { 0x4000000UL });
        public static readonly BitSet _COLON_in_labelledStatement5477 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _statement_in_labelledStatement5479 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _THROW_in_throwStatement5499 = new BitSet(new ulong[] { 0x4040100A00000020UL, 0x416000460A210UL, 0x451410008UL });
        public static readonly BitSet _expression_in_throwStatement5503 = new BitSet(new ulong[] { 0x0UL });
        public static readonly BitSet _semic_in_throwStatement5505 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _TRY_in_tryStatement5521 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _block_in_tryStatement5523 = new BitSet(new ulong[] { 0x200000000400000UL });
        public static readonly BitSet _catchClause_in_tryStatement5527 = new BitSet(new ulong[] { 0x200000000000002UL });
        public static readonly BitSet _finallyClause_in_tryStatement5529 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _finallyClause_in_tryStatement5534 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _CATCH_in_catchClause5548 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _LPAREN_in_catchClause5550 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _Identifier_in_catchClause5552 = new BitSet(new ulong[] { 0x0UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_catchClause5554 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _block_in_catchClause5556 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _FINALLY_in_finallyClause5568 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _block_in_finallyClause5570 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _FUNCTION_in_functionDeclaration5606 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _Identifier_in_functionDeclaration5610 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _formalParameterList_in_functionDeclaration5614 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _functionDeclarationBody_in_functionDeclaration5616 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _FUNCTION_in_functionExpression5671 = new BitSet(new ulong[] { 0x0UL, 0x4008000UL });
        public static readonly BitSet _Identifier_in_functionExpression5673 = new BitSet(new ulong[] { 0x0UL, 0x4000000UL });
        public static readonly BitSet _formalParameterList_in_functionExpression5676 = new BitSet(new ulong[] { 0x0UL, 0x200000UL });
        public static readonly BitSet _functionExpressionBody_in_functionExpression5678 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LPAREN_in_formalParameterList5689 = new BitSet(new ulong[] { 0x0UL, 0x8000UL, 0x1UL });
        public static readonly BitSet _Identifier_in_formalParameterList5693 = new BitSet(new ulong[] { 0x8000000UL, 0x0UL, 0x1UL });
        public static readonly BitSet _COMMA_in_formalParameterList5697 = new BitSet(new ulong[] { 0x0UL, 0x8000UL });
        public static readonly BitSet _Identifier_in_formalParameterList5699 = new BitSet(new ulong[] { 0x8000000UL, 0x0UL, 0x1UL });
        public static readonly BitSet _RPAREN_in_formalParameterList5707 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LBRACE_in_functionDeclarationBody5720 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0xA00416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _functionDeclarationBodyWithoutBraces_in_functionDeclarationBody5722 = new BitSet(new ulong[] { 0x0UL, 0x2000000000000000UL });
        public static readonly BitSet _RBRACE_in_functionDeclarationBody5725 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _LBRACE_in_functionExpressionBody5738 = new BitSet(new ulong[] { 0x4840104A20004020UL, 0xA00416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _functionExpressionBodyWithoutBraces_in_functionExpressionBody5740 = new BitSet(new ulong[] { 0x0UL, 0x2000000000000000UL });
        public static readonly BitSet _RBRACE_in_functionExpressionBody5743 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _sourceElement_in_functionExpressionBodyWithoutBraces5760 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _sourceElement_in_functionExpressionBodyWithoutBraces5762 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _sourceElement_in_functionDeclarationBodyWithoutBraces5829 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _sourceElement_in_functionDeclarationBodyWithoutBraces5831 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _sourceElement_in_program5883 = new BitSet(new ulong[] { 0x4840104A20004022UL, 0x800416000460A230UL, 0x6673490028UL });
        public static readonly BitSet _functionDeclaration_in_sourceElement5954 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _statement_in_sourceElement5959 = new BitSet(new ulong[] { 0x2UL });
    }
    #endregion Follow sets
}
